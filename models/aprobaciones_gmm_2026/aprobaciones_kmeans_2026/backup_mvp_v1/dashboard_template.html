<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero de Clustering (K-Means) - BCIE</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
<style>
    :root { 
        --font-main: 'Inter', sans-serif;
        --primary: #105682; --text-dark: #1e293b; --text-light: #64748b; --bg-body: #f8fafc; --bg-card: #ffffff; --border: #e2e8f0; --hover: #f1f5f9; --success: #10b981; --danger: #ef4444; --tooltip-bg: #1e293b; --tooltip-text: #ffffff;
    }
    [data-theme="dark"] { 
        --primary: #38bdf8; --text-dark: #f1f5f9; --text-light: #94a3b8; --bg-body: #0f172a; --bg-card: #1e293b; --border: #334155; --hover: #334155; --tooltip-bg: #ffffff; --tooltip-text: #0f172a; 
    }
    * { box-sizing: border-box; }
    body { font-family: var(--font-main); background: var(--bg-body); margin: 0; padding: 0; color: var(--text-dark); transition: background 0.3s; }
    
    /* NAV (Exact match to Prophet) */
    .top-nav { position: fixed; top: 0; left: 0; right: 0; height: 80px; background: var(--bg-card); border-bottom: 5px solid var(--primary); display: flex; align-items: center; justify-content: space-between; padding: 0 30px; z-index: 50; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
    .header-title h1 { margin: 0; font-size: 24px; font-weight: 800; color: var(--primary); }
    .header-title .subtitle { font-size: 14px; color: var(--text-light); margin-top: 4px; }
    
    .nav-controls { display: flex; align-items: center; gap: 15px; }
    .update-badge { font-size: 11px; background: var(--hover); color: var(--text-light); padding: 5px 10px; border-radius: 4px; }

    /* TOGGLES (Exact match) */
    .toggle-wrapper { display: flex; flex-direction: column; align-items: center; gap: 4px; }
    .toggle-switch { position: relative; width: 80px; height: 30px; background: var(--bg-body); border: 1px solid var(--border); border-radius: 15px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 2px; transition: background 0.3s; }
    .toggle-switch.active { background: #94a3b8; border-color: #94a3b8; }
    .toggle-knob { width: 24px; height: 24px; background: white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.3s; position: absolute; left: 3px; z-index: 2; }
    .toggle-switch.active .toggle-knob { transform: translateX(50px); }
    .toggle-icon { font-size: 14px; z-index: 1; margin: 0 8px; user-select: none; }
    .toggle-labels { display: flex; justify-content: space-between; width: 100%; font-size: 9px; font-weight: 700; color: var(--text-light); padding: 0 6px; }
    .toggle-labels span { flex: 1; text-align: center; }

    /* BUTTONS (Exact match) */
    .btn-action { font-family: var(--font-main); padding: 6px 16px; border-radius: 6px; font-size: 13px; font-weight: 700; cursor: pointer; border: 1px solid transparent; transition: 0.2s; min-width: 100px; text-align: center; }
    .btn-ghost-primary { background: transparent; border: 1px solid var(--primary); color: var(--primary); }
    .btn-ghost-primary:hover { background: var(--hover); }
    .btn-solid-primary { background: var(--primary); border: 1px solid var(--primary); color: white; }
    .btn-solid-primary:hover { opacity: 0.9; }
    
    [data-theme="dark"] .btn-ghost-primary { border-color: var(--primary); color: var(--primary); }
    [data-theme="dark"] .btn-solid-primary { color: #0f172a; } /* Dark text on light blue */

    /* LAYOUT */
    .dashboard-container { margin-top: 100px; padding: 20px; max-width: 99%; margin-left: auto; margin-right: auto; display: grid; gap: 20px; grid-template-columns: 1fr 850px 600px; height: calc(100vh - 120px); min-width: 1900px; } /* Wider Right Col */
    
    .left-col { display: flex; flex-direction: column; gap: 20px; height: 100%; overflow: hidden; padding-right: 5px; }
    .mid-col { height: 100%; overflow: hidden; display: flex; flex-direction: column; gap: 20px; }
    .right-col { height: 100%; overflow: hidden; display: flex; flex-direction: column; gap: 20px; }
    
    .card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 20px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); display: flex; flex-direction: column; transition: transform 0.2s; }
    .card:hover { border-color: var(--primary); }
    .card-title { font-size: 14px; font-weight: 700; color: var(--primary); margin: 0 0 15px 0; border-bottom: 2px solid var(--hover); padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
    
    .kpi-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-top: auto; }
    .kpi-box { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 15px; display: flex; flex-direction: column; justify-content: center; align-items: center; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.08); min-height: 100px; } /* Fixed min-height */
    .kpi-val { font-size: 28px; font-weight: 800; color: var(--primary); line-height: 1.2; }
    .kpi-lbl { font-size: 11px; font-weight: 700; color: var(--text-light); text-transform: uppercase; margin-top: 5px; }

    .chart-container { width: 100%; position: relative; } /* Removed fixed height */
    #dendrogram-chart { flex: 1; min-height: 0; }

    /* TABLE */
    .table-container { flex: 1; overflow: auto; border: 1px solid var(--border); border-radius: 8px; }
    table { width: 100%; border-collapse: collapse; font-size: 11px; color: var(--text-dark); }
    th { text-align: left; padding: 10px; background: var(--hover); color: var(--text-dark); font-weight: 800; position: sticky; top: 0; border-bottom: 2px solid var(--primary); z-index: 10; }
    td { padding: 8px 10px; border-bottom: 1px solid var(--border); }
    tr:nth-child(even) { background: rgba(0,0,0,0.01); }
    tr:hover { background: rgba(16, 86, 130, 0.05); }
    
    .cluster-tag { display: inline-block; padding: 4px 12px; border-radius: 99px; font-weight: 700; font-size: 10px; color: white; min-width: 130px; text-align: center; line-height: 1.2; white-space: nowrap; } /* Wider and no-wrap */

    /* ... */




    /* FOOTER */
    footer { grid-column: 1 / -1; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border); text-align: center; }
    .footer-legal { font-size: 10px; color: var(--primary); font-weight: 700; }
    .footer-disclaimer { font-size: 10px; color: var(--text-light); margin-top: 5px; font-style: italic; }

    /* CUSTOM LEGEND */
    .custom-legend { display: flex; flex-direction: column; gap: 8px; margin: 5px 0 15px 0; flex-shrink: 0; }
    .legend-row { display: flex; justify-content: center; gap: 25px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 8px; font-size: 11px; font-weight: 600; color: var(--text-dark); }
</style>
</head>
<body id="dashboard-body">
    <nav class="top-nav">
        <div class="header-title">
            <h1 data-key="title" id="lbl-main">Dashboard de Clustering (K-Means)</h1>
            <div class="subtitle" data-key="subtitle" id="lbl-sub">Segmentaci√≥n de Pa√≠ses BCIE</div>
        </div>
        <div class="nav-controls">
            <div style="display:flex; gap:10px; margin-right:15px">
                <button class="btn-action btn-ghost-primary" onclick="takeScreenshot()">
                    <span id="btn-snap-txt">Captura</span>
                </button>
                <button class="btn-action btn-solid-primary" onclick="generatePDF()">
                    <span id="btn-pdf-txt">PDF</span>
                </button>
            </div>
            
            <div class="update-badge" id="lbl-update">Datos Actualizados: {{UPDATE_TIME}}</div>
            
            <!-- THEME TOGGLE -->
            <div class="toggle-wrapper">
                <div class="toggle-switch" id="btn-theme" onclick="toggleTheme()" title="Tema">
                    <div class="toggle-knob"></div>
                    <span class="toggle-icon">‚òÄÔ∏è</span>
                    <span class="toggle-icon">üåô</span>
                </div>
                <div class="toggle-labels">
                    <span id="lbl-theme-light">Claro</span>
                    <span id="lbl-theme-dark">Oscuro</span>
                </div>
            </div>

            <!-- LANG TOGGLE -->
            <div class="toggle-wrapper">
                <div class="toggle-switch" id="btn-lang" onclick="toggleLang()" title="Idioma">
                    <div class="toggle-knob"></div>
                </div>
                <div class="toggle-labels">
                    <span id="lbl-lang-es">Esp</span>
                    <span id="lbl-lang-en">Ing</span>
                </div>
            </div>
        </div>
    </nav>

    <div class="dashboard-container">
        <!-- LEFT COLUMN: GRAPHS ONLY -->
        <div class="left-col">
            <!-- ELBOW CHART (Fixed Height) -->
            <div class="card" style="flex: 0 0 350px;">
                <h3 class="card-title">
                    <span data-key="elbow_title">M√©todo del Codo (Optimizaci√≥n de K)</span>
                </h3>
                <div id="elbow-chart" class="chart-container" style="height: 100%;"></div>
            </div>

            <!-- SCATTER CHART (Flex Fill) -->
            <div class="card" style="flex: 1; display:flex; flex-direction:column; overflow:hidden;">
                <h3 class="card-title">
                    <span data-key="scatter_title">Segmentaci√≥n de Pa√≠ses</span>
                    <span data-key="scatter_subtitle" style="font-size:11px; font-weight:400; color:var(--text-light);">Monto vs Aprobaciones (con Envolventes Convexas)</span>
                </h3>
                <div id="scatter-legend" class="custom-legend"></div>
                <div id="scatter-chart" class="chart-container" style="flex:1; min-height:0;"></div>
            </div>
        </div>



        <!-- MIDDLE COLUMN: KPIS + TABLE -->
        <div class="mid-col">
            <!-- KPIS -->
            <div class="card" style="flex: 0 0 auto;">
                <h3 class="card-title" data-key="kpi_title">Resumen General</h3>
                <div class="kpi-grid">
                    <div class="kpi-box">
                        <div class="kpi-lbl" data-key="kpi_countries">Registros</div>
                        <div class="kpi-val" id="kpi-countries">0</div>
                    </div>
                    <div class="kpi-box">
                        <div class="kpi-lbl" data-key="kpi_clusters">Clusters</div>
                        <div class="kpi-val" id="kpi-k">0</div>
                    </div>
                    <div class="kpi-box">
                        <div class="kpi-lbl" data-key="kpi_sil">Calidad (Silueta)</div>
                        <div class="kpi-val" id="kpi-score">0.00</div>
                    </div>
                     <div class="kpi-box">
                        <div class="kpi-lbl" data-key="kpi_amount">Monto Total</div>
                        <div class="kpi-val" id="kpi-total-monto">$0</div>
                    </div>
                </div>
            </div>

            <!-- TABLE -->
            <div class="card" style="flex: 1; overflow: hidden;">
                <h3 class="card-title" data-key="table_title">Detalle por Pa√≠s y A√±o</h3>
                <div class="table-container">
                    <table id="data-table">
                        <thead>
                            <tr>
                                <th data-key="col_year">A√±o</th>
                                <th data-key="col_country">Pa√≠s</th>
                                <th data-key="col_amount">Monto (USD)</th>
                                <th data-key="col_count">Aprobaciones</th>
                                <th data-key="col_sector">Sector</th>
                                <th data-key="col_dist">Distancia</th>
                                <th data-key="col_cluster">Segmento</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- RIGHT COLUMN: PROFILE + MATRIX -->
        <div class="right-col">
            <!-- RADAR CHART (PROFILE) -->
            <div class="card" style="flex: 1; min-height: 0; display:flex; flex-direction:column; overflow: hidden;">
                <h3 class="card-title">
                    <span data-key="radar_title">Perfil de los Clusters</span>
                    <span data-key="radar_subtitle" style="font-size:11px; font-weight:400; color:var(--text-light);">Comparativa de Centroides</span>
                </h3>
                <div id="radar-chart" class="chart-container" style="flex:1; min-height:0;"></div>
            </div>

            <!-- MATRIX -->
            <div class="card" style="flex: 0 0 auto;">
                <h3 class="card-title">
                    <span data-key="matrix_title">Matriz de Segmentos</span>
                    <span data-key="matrix_subtitle" style="font-size:11px; font-weight:400; color:var(--text-light);">Conteo por Pa√≠s</span>
                </h3>
                <div class="table-container" style="height: auto; max-height: 500px; overflow: auto;">
                    <table id="matrix-table">
                        <thead>
                            <tr id="matrix-header">
                                <th>Pa√≠s</th>
                                <!-- Columns injected by JS -->
                            </tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>

        <footer>
            <div data-key="footer_legal" class="footer-legal">¬© 2026 | UNIR‚ÄìBCIE | Trabajo de Colaboraci√≥n Acad√©mica | Proyecto Final de M√°ster | Equipo 03-D | Desarrollado por Edgar Garc√≠a, Norman Sabill√≥n y Wilson Aguilar | Todos los derechos reservados.</div>
            <div data-key="footer_disclaimer" class="footer-disclaimer">Este tablero presenta modelos de machine learning para fines acad√©micos y de an√°lisis.</div>
        </footer>

    </div>

<script>
    // INJECTED DATA
    const dataClusters = JSON.parse('{{DATA_CLUSTERS}}');
    const metricsData = JSON.parse('{{DATA_METRICS}}');
    const centroidsData = JSON.parse('{{DATA_CENTROIDS}}');
    
    // CLUSTER NAMING LOGIC
    // Sort centroids by Amount to determine hierarchy
    const sortedCentroids = [...centroidsData].sort((a, b) => a.monto - b.monto);
    const clusterLabels = {};
    
    // Assign names based on rank
    sortedCentroids.forEach((c, index) => {
        let label = `Cluster ${c.cluster}`;
        if (sortedCentroids.length === 3) {
            if (index === 0) label = "Proyectos Menores";     // Lowest Amount
            if (index === 1) label = "Proyectos Regulares";   // Mid Amount
            if (index === 2) label = "Estrat√©gicos";          // High Amount
        } else {
            if (index === 0) label = "Nivel Bajo";
            else if (index === sortedCentroids.length - 1) label = "Nivel Superior";
            else label = `Nivel Medio ${index}`;
        }
        clusterLabels[c.cluster] = label;
    });

    // LANGUAGE DICTIONARY
    const langData = {
        es: {
            title: "Dashboard de Clustering (K-Means)",
            subtitle: "Segmentaci√≥n Inteligente de Pa√≠ses BCIE",
            elbow_title: "Validaci√≥n (Suavizada)",
            scatter_title: "Mapa de Segmentaci√≥n",
            scatter_subtitle: "Monto vs Aprobaciones (con Envolventes Convexas)",
            radar_title: "Perfil por Segmento (Score 0‚Äì100)",
            radar_subtitle: "Comparaci√≥n relativa: Monto vs # de Proyectos (centroides)",
            matrix_title: "Matriz de Segmentos",
            matrix_subtitle: "Conteo por Pa√≠s",
            kpi_title: "Resumen General",
            kpi_countries: "Registros",
            kpi_clusters: "Clusters",
            kpi_sil: "Calidad (Silueta)",
            kpi_amount: "Monto Total",
            table_title: "Detalle de Segmentos",
            col_country: "Pa√≠s",
            col_year: "A√±o",
            col_amount: "Monto",
            col_cluster: "Segmento",
            col_count: "Aprobaciones",
            col_sector: "Sector",
            col_dist: "Distancia",
            lbl_monto: "Monto",
            lbl_proyectos: "Proyectos",
            desc_estr: "Monto alto / Proyectos bajos",
            desc_regu: "Monto medio / Proyectos altos",
            desc_meno: "Monto bajo / Proyectos bajos",
            txt_total_general: "TOTAL GENERAL",
            txt_theme_light: "Claro", txt_theme_dark: "Oscuro",
            txt_lang_es: "Esp", txt_lang_en: "Ing",
            txt_snap: "Captura", txt_pdf: "PDF",
            footer_legal: "¬© 2026 | UNIR‚ÄìBCIE | Trabajo de Colaboraci√≥n Acad√©mica | Proyecto Final de M√°ster | Equipo 03-D | Desarrollado por Edgar Garc√≠a, Norman Sabill√≥n y Wilson Aguilar | Todos los derechos reservados.",
            footer_disclaimer: "Este tablero utiliza el algoritmo K-Means para agrupar proyectos seg√∫n patrones hist√≥ricos de monto y aprobaciones. Los resultados son para fines acad√©micos y de an√°lisis, y no constituyen un compromiso financiero vinculante por parte del BCIE.",
            // Content Maps
            sectors: { "Sector Privado": "Sector Privado", "Sector P√∫blico": "Sector P√∫blico" },
            countries: { 
                "Belice": "Belice", "M√©xico": "M√©xico", "Panam√°": "Panam√°", "Rep√∫blica Dominicana": "Rep√∫blica Dominicana", "Espa√±a": "Espa√±a",
                "Honduras": "Honduras", "Costa Rica": "Costa Rica", "Guatemala": "Guatemala", "El Salvador": "El Salvador", "Nicaragua": "Nicaragua",
                "Colombia": "Colombia", "Argentina": "Argentina", "Cuba": "Cuba", "Regional": "Regional"
            },
            clusterNames: ["Proyectos Menores", "Proyectos Regulares", "Estrat√©gicos"]
        },
        en: {
            title: "Clustering Dashboard (K-Means)",
            subtitle: "BCIE Country Segmentation",
            elbow_title: "Validation (Elbow + Silhouette)",
            scatter_title: "Country Segmentation",
            scatter_subtitle: "Amount vs Approvals (with Convex Hulls)",
            radar_title: "Segment Profile (Score 0‚Äì100)",
            radar_subtitle: "Relative comparison: Amount vs # of Projects (centroids)",
            matrix_title: "Segment Matrix",
            matrix_subtitle: "Counts per Country",
            kpi_title: "General Overview",
            kpi_countries: "Records",
            kpi_clusters: "Clusters (K)",
            kpi_sil: "Quality (Silhouette)",
            kpi_amount: "Total Amount",
            table_title: "Detailed View",
            col_country: "Country",
            col_year: "Year",
            col_amount: "Amount (USD)",
            col_count: "Approvals",
            col_sector: "Sector",
            col_dist: "Distance",
            col_cluster: "Cluster",
            lbl_monto: "Amount",
            lbl_proyectos: "Projects",
            desc_estr: "High Amount / Low Projects",
            desc_regu: "Medium Amount / High Projects",
            desc_meno: "Low Amount / Low Projects",
            txt_total_general: "GRAND TOTAL",
            txt_theme_light: "Light", txt_theme_dark: "Dark",
            txt_lang_es: "Esp", txt_lang_en: "Eng",
            txt_snap: "Snapshot", txt_pdf: "PDF",
            footer_legal: "¬© 2026 | UNIR‚ÄìBCIE | Academic Collaboration Work | Master's Final Project | Team 03-D | Developed by Edgar Garc√≠a, Norman Sabill√≥n and Wilson Aguilar | All rights reserved.",
            footer_disclaimer: "This dashboard utilizes the K-Means algorithm to group projects based on historical patterns of amount and approvals. The results are for academic and analytical purposes only, and do not constitute a binding financial commitment by CABEI (BCIE).",
            // Content Maps
            sectors: { "Sector Privado": "Private Sector", "Sector P√∫blico": "Public Sector" },
            countries: { 
                "Belice": "Belize", "M√©xico": "Mexico", "Panam√°": "Panama", "Rep√∫blica Dominicana": "Dominican Republic", "Espa√±a": "Spain",
                "Honduras": "Honduras", "Costa Rica": "Costa Rica", "Guatemala": "Guatemala", "El Salvador": "El Salvador", "Nicaragua": "Nicaragua",
                "Colombia": "Colombia", "Argentina": "Argentina", "Cuba": "Cuba", "Regional": "Regional"
            },
            clusterNames: ["Minor Projects", "Regular Projects", "Strategic Projects"]
        }
    };

    function updateClusterLabels() {
        const txt = langData[currentLang];
        sortedCentroids.forEach((c, i) => {
            clusterLabels[c.cluster] = txt.clusterNames[i] || `Cluster ${c.cluster}`;
        });
    }

    let currentLang = 'es';
    let currentTheme = 'light';

    function init() {
        updateClusterLabels();
        renderTable();
        renderCharts();
        renderMatrix();
        updateKPIs();
        updateText();
    }

    function renderMatrix() {
        const matrixBody = document.querySelector('#matrix-table tbody');
        const matrixHeader = document.querySelector('#matrix-header');
        matrixBody.innerHTML = '';
        
        // 1. Get Segments (Clusters) sorted
        const clusterIds = sortedCentroids.map(c => c.cluster);
        
        // Update Headers
        const txt = langData[currentLang];
        let headerHTML = `<th style="text-align:left;">${txt.col_country}</th>`;
        clusterIds.forEach(cid => {
             // Use full label as requested
             const label = clusterLabels[cid];
             headerHTML += `<th style="text-align:center">${label}</th>`;
        });
        headerHTML += `<th style="text-align:center">Total</th>`;
        matrixHeader.innerHTML = headerHTML;

        // 2. Aggregate Data and Calculate Column Totals
        const countryMap = {};
        const colTotals = {}; 
        clusterIds.forEach(id => colTotals[id] = 0);
        let grandTotal = 0;
        
        dataClusters.forEach(d => {
            const pais = toTitleCase(d.Pais);
            if(!countryMap[pais]) {
                countryMap[pais] = {
                    total: 0,
                    counts: {} // {clusterId: count}
                };
                clusterIds.forEach(id => countryMap[pais].counts[id] = 0);
            }
            countryMap[pais].counts[d.Cluster]++;
            countryMap[pais].total++;
            
            // Accumulate Grand Totals
            colTotals[d.Cluster]++;
            grandTotal++;
        });

        // 3. Sort Countries by Total
        const sortedCountries = Object.keys(countryMap).sort((a,b) => countryMap[b].total - countryMap[a].total);

        // Define uniform style (matching renderTable)
        const cellStyle = 'vertical-align: middle; font-size: 11px; color: var(--text-dark);';

        // 4. Render Data Rows
        sortedCountries.forEach(pais => {
            const data = countryMap[pais];
            const tr = document.createElement('tr');
            const translatedPais = txt.countries[pais] || pais;
            
            let rowHTML = `<td style="${cellStyle}">${translatedPais}</td>`;
            clusterIds.forEach(cid => {
                const count = data.counts[cid];
                // Clean plain style, matching Detail table
                rowHTML += `<td style="${cellStyle} text-align:center;">${count}</td>`;
            });
            rowHTML += `<td style="${cellStyle} text-align:center; font-weight:700;">${data.total}</td>`;
            
            tr.innerHTML = rowHTML;
            matrixBody.appendChild(tr);
        });

        // 5. Render Total Row
        const totalTr = document.createElement('tr');
        totalTr.style.backgroundColor = 'var(--hover)'; 
        totalTr.style.borderTop = '2px solid var(--primary)';
        
        let totalHTML = `<td style="${cellStyle} font-weight:800;">${txt.txt_total_general}</td>`;
        clusterIds.forEach(cid => {
             totalHTML += `<td style="${cellStyle} text-align:center; font-weight:800;">${colTotals[cid]}</td>`;
        });
        totalHTML += `<td style="${cellStyle} text-align:center; font-weight:800;">${grandTotal}</td>`;
        
        totalTr.innerHTML = totalHTML;
        matrixBody.appendChild(totalTr);
    }

    function updateKPIs() {
        document.getElementById('kpi-countries').innerText = dataClusters.length;
        const uniqueClusters = [...new Set(dataClusters.map(d => d.Cluster))];
        const numK = uniqueClusters.length;
        document.getElementById('kpi-k').innerText = numK;
        
        // Silhouette for CURRENT K
        // metricsData has [{k, wcss, silhouette}]
        const metric = metricsData.find(d => d.k === numK);
        if(metric) {
            const val = metric.silhouette;
            document.getElementById('kpi-score').innerText = val.toFixed(2);
        }

        // Total Monto
        const total = dataClusters.reduce((sum, d) => sum + d.Monto_Aprobado, 0);
        let fmt = total.toLocaleString();
        if(total > 1e9) fmt = `$${(total/1e9).toFixed(1)}B`;
        else if(total > 1e6) fmt = `$${(total/1e6).toFixed(1)}M`;
        document.getElementById('kpi-total-monto').innerText = fmt;
    }

    function convexHull(points) {
        points.sort((a, b) => a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);
        const n = points.length;
        if (n <= 2) return points;
        const cross = (a, b, o) => (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
        const lower = [];
        for (let i = 0; i < n; i++) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) lower.pop();
            lower.push(points[i]);
        }
        const upper = [];
        for (let i = n - 1; i >= 0; i--) {
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) upper.pop();
            upper.push(points[i]);
        }
        upper.pop(); lower.pop();
        return lower.concat(upper);
    }

    // Helper for title case
    function toTitleCase(str) {
        if(!str) return '';
        return str.toLowerCase().split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    }

    // --- RENDER TABLE ---
    function renderTable() {
        const tbody = document.querySelector('#data-table tbody');
        tbody.innerHTML = '';
        const colors = ['#105682', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
        const txt = langData[currentLang];
        
        // 1. Sort Data: Year Desc, then Country Asc
        const sortedData = [...dataClusters].sort((a,b) => {
            const ya = a.Anio || a.Anio_Origen || 0;
            const yb = b.Anio || b.Anio_Origen || 0;
            if(yb !== ya) return yb - ya;
            return a.Pais.localeCompare(b.Pais);
        });

        // 2. Render
        sortedData.slice(0, 500).forEach(row => {
            const tr = document.createElement('tr');
            const color = colors[row.Cluster % colors.length];
            const anio = row.Anio || row.Anio_Origen || '-';
            const label = clusterLabels[row.Cluster];
            
            // Translate Content
            const rawSector = row.Sector_Economico || '-';
            const sector = txt.sectors[rawSector] || rawSector;
            const rawPais = toTitleCase(row.Pais);
            const pais = txt.countries[rawPais] || rawPais;
            
            const dist = row.Distancia_Centroide ? parseFloat(row.Distancia_Centroide).toFixed(2) : '-';
            const ops = row.CANTIDAD_APROBACIONES || 1;
            
            const tdStyle = 'vertical-align: middle;'; 

            tr.innerHTML = `
                <td style="${tdStyle}">${anio}</td>
                <td style="${tdStyle}">${pais}</td>
                <td style="${tdStyle}">$${parseFloat(row.Monto_Aprobado).toLocaleString(undefined, {minimumFractionDigits:0, maximumFractionDigits:0})}</td>
                <td style="${tdStyle}">${ops}</td>
                <td style="${tdStyle}">${sector}</td>
                <td style="${tdStyle}">${dist}</td>
                <td style="${tdStyle}"><span class="cluster-tag" style="background-color:${color};">${label}</span></td>
            `;
            tbody.appendChild(tr);
        });
    }

    // --- RENDER CHARTS ---
    function renderCharts() {
        const colors = ['#105682', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
        const isDark = currentTheme === 'dark';
        const txtColor = isDark ? '#f1f5f9' : '#1e293b';
        const gridColor = isDark ? '#334155' : '#e2e8f0';

        // Get Text Resources
        const txt = langData[currentLang];
        
        // clusterLabels are now updated by updateClusterLabels()

        const uniqueClusters = [...new Set(dataClusters.map(d => d.Cluster))].sort();
        const currentK = uniqueClusters.length;

        // 1. ELBOW & SILHOUETTE
        const traceElbow = {
            x: metricsData.map(d => d.k),
            y: metricsData.map(d => d.wcss),
            name: currentLang === 'es' ? 'Inercia' : 'Inertia',
            mode: 'lines',
            line: {color: '#ef4444', width: 3, shape: 'spline', smoothing: 1.3}, 
            type: 'scatter'
        };
        const traceSil = {
            x: metricsData.map(d => d.k),
            y: metricsData.map(d => d.silhouette),
            name: currentLang === 'es' ? 'Silueta' : 'Silhouette',
            yaxis: 'y2',
            mode: 'lines',
            line: {color: '#10b981', width: 3, shape: 'spline', smoothing: 1.3}, 
            type: 'scatter'
        };
        
        // HIGHLIGHT OPTIMAL K
        const bestMetric = metricsData.find(d => d.k === currentK);
        // Fallback if metric not found
        const bestK = bestMetric ? bestMetric.k : currentK;
        const bestWcss = bestMetric ? bestMetric.wcss : 0;
        const bestSil = bestMetric ? bestMetric.silhouette : 0;
        const lblOpt = currentLang === 'es' ? 'K √ìptimo' : 'Optimal K';

        const traceBestK_Elbow = {
            x: [bestK], y: [bestWcss],
            mode: 'markers', name: lblOpt,
            marker: {size: 14, color: '#ef4444', symbol: 'star', line: {width:2, color:'white'}},
            hoverinfo: 'skip', showlegend: false
        };
        const traceBestK_Sil = {
            x: [bestK], y: [bestSil],
            yaxis: 'y2', mode: 'markers', name: lblOpt,
            marker: {size: 14, color: '#10b981', symbol: 'star', line: {width:2, color:'white'}},
            hoverinfo: 'skip', showlegend: false
        };

        Plotly.newPlot('elbow-chart', [traceElbow, traceSil, traceBestK_Elbow, traceBestK_Sil], {
            margin: {t:40, l:50, r:40, b:40},
            paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
            font: { family: 'Inter', color: txtColor },
            xaxis: {title: 'K Clusters', gridcolor: gridColor},
            yaxis: {title: currentLang==='es'?'Inercia':'Inertia', gridcolor: gridColor},
            yaxis2: {overlaying: 'y', side: 'right', showgrid:false, range:[0,1]},
            legend: {orientation: 'h', y: 1.2},
            annotations: bestMetric ? [{
                x: bestK, y: bestSil, yref: 'y2',
                text: `K=${currentK}`, showarrow: true, arrowhead: 2, ax: 0, ay: -40, font: {color: '#10b981', weight: 'bold'}
            }] : []
        }, {displayModeBar: false});

        // 2. SCATTER + HULLS
        const traces = [];
        const centroidLegendTraces = [];
        const clusterPointTraces = [];
        const hullTraces = [];
        const centroidDrawTraces = [];
        
        // Helper for transparency
        const hexToRgba = (hex, alpha) => {
            let c;
            if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length== 3){
                    c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                }
                c= '0x'+c.join('');
                return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+alpha+')';
            }
            return hex;
        };
        
        uniqueClusters.forEach(clusterId => {
            const clusterData = dataClusters.filter(d => d.Cluster === clusterId);
            const points = clusterData.map(d => [d.Monto_Aprobado, d.CANTIDAD_APROBACIONES]);
            const hullPoints = convexHull(points);
            if(hullPoints.length>0) hullPoints.push(hullPoints[0]);
            
            const colorHex = colors[clusterId % colors.length];
            const colorRgba = hexToRgba(colorHex, 0.4); 

            // 1. Hull
            hullTraces.push({
                x: hullPoints.map(p => p[0]), y: hullPoints.map(p => p[1]),
                fill: 'toself', type: 'scatter', mode: 'lines',
                line: {width: 0, color: colorHex},
                fillcolor: colorHex, opacity: 0.15,
                hoverinfo: 'skip', showlegend: false
            });
            
            // 2. Points
            clusterPointTraces.push({
                x: clusterData.map(d => d.Monto_Aprobado),
                y: clusterData.map(d => d.CANTIDAD_APROBACIONES),
                mode: 'markers', type: 'scatter',
                name: clusterLabels[clusterId], // Translated by prev step
                text: clusterData.map(d => `${txt.countries[toTitleCase(d.Pais)] || toTitleCase(d.Pais)}<br>${clusterLabels[clusterId]}<br>$${d.Monto_Aprobado.toLocaleString()}`),
                marker: { 
                    size: 9, 
                    color: colorRgba, 
                    line: {color: colorHex, width: 2} 
                },
                legendgroup: `group_cluster_${clusterId}`,
                showlegend: true
            });

            // 3. Centroids
            const cent = centroidsData.find(c => c.cluster === clusterId);
            if(cent) {
                // Translated Prefix
                const prefix = currentLang === 'es' ? 'Centro ' : 'Center ';
                const lbl = prefix + clusterLabels[clusterId];

                // Legend Entry (First)
                centroidLegendTraces.push({
                    x: [cent.monto], y: [cent.aprobaciones],
                    mode: 'markers', type: 'scatter',
                    name: lbl,
                    marker: { size: 18, symbol: 'star', color: colorHex, line: {width:2, color:'white'} },
                    hoverinfo: 'skip', 
                    legendgroup: `group_centroid_${clusterId}`, 
                    showlegend: true
                });
                
                // Draw Entry (Last)
                centroidDrawTraces.push({
                    x: [cent.monto], y: [cent.aprobaciones],
                    mode: 'markers', type: 'scatter',
                    name: lbl,
                    marker: { size: 20, symbol: 'star', color: colorHex, line: {width:2, color:'white'} },
                    hoverinfo: 'text', text: [`${lbl}<br>$${parseFloat(cent.monto).toLocaleString()}`],
                    showlegend: false
                });
            }
        });

        // ORDER: Centroids(Legend Mode) -> Hulls(Bg) -> Points(Middle) -> Centroids(Draw Mode)
        const finalScatterTraces = [
            ...centroidLegendTraces,
            ...hullTraces,
            ...clusterPointTraces,
            ...centroidDrawTraces
        ];

        // 2B. POPULATE CUSTOM LEGEND (HTML)
        const legendDiv = document.getElementById('scatter-legend');
        const pref = currentLang === 'es' ? 'Centro ' : 'Center ';
        
        // Row 1: Centroids
        let legHTML = '<div class="legend-row">';
        sortedCentroids.forEach(c => {
            const color = colors[c.cluster % colors.length];
            const name = pref + clusterLabels[c.cluster];
            legHTML += `<div class="legend-item"><span style="color:${color}; font-size:16px;">‚òÖ</span> ${name}</div>`;
        });
        legHTML += '</div>';

        // Row 2: Segments
        legHTML += '<div class="legend-row">';
        sortedCentroids.forEach(c => {
            const color = colors[c.cluster % colors.length];
            const name = clusterLabels[c.cluster];
            legHTML += `<div class="legend-item"><span style="color:${color}; font-size:16px;">‚óè</span> ${name}</div>`;
        });
        legHTML += '</div>';
        legendDiv.innerHTML = legHTML;

        // Translated Axes
        const axX = currentLang === 'es' ? 'Monto (Escala Logar√≠tmica)' : 'Amount (Logarithmic Scale)';
        const axY = currentLang === 'es' ? 'Aprobaciones' : 'Approvals';

        Plotly.newPlot('scatter-chart', finalScatterTraces, {
            margin: {t:10, l:50, r:20, b:40}, // Reduced top margin as legend is manual now
            paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
            font: { family: 'Inter', color: txtColor },
            xaxis: {title: axX, type: 'log', gridcolor: gridColor},
            yaxis: {title: axY, gridcolor: gridColor},
            hovermode: 'closest', 
            showlegend: false // DISABLED NATIVE LEGEND
        }, {displayModeBar: false});

        // 3. DUMBBELL CHART (Profile)
        // 1. Sort centroids: Menores -> Regulares -> Estrat√©gicos
        const order = txt.clusterNames; // Use translated cluster names for sorting order
        centroidsData_copy = [...centroidsData].sort((a,b) => {
             const la = clusterLabels[a.cluster];
             const lb = clusterLabels[b.cluster];
             return order.indexOf(la) - order.indexOf(lb);
        });
        
        // Helper
        function fmtMoney(val) {
            if(val >= 1e9) return '$' + (val/1e9).toFixed(1) + 'B';
            if(val >= 1e6) return '$' + (val/1e6).toFixed(1) + 'M';
            if(val >= 1e3) return '$' + (val/1e3).toFixed(0) + 'K';
            return '$' + val.toFixed(0);
        }

        // 2. Calculate Min/Max per variable for 0-100 Normalization (using original full dataset range if possible, or relative to these 3)
        // User said: "Opci√≥n B: Min-Max por m√©trica, pero sobre centroides (solo 3 valores)" -> "Garantiza que solo 1 sea 100".
        const mVals = centroidsData_copy.map(c => parseFloat(c.monto));
        const aVals = centroidsData_copy.map(c => parseFloat(c.aprobaciones));
        
        const minMonto = Math.min(...mVals); const maxMonto = Math.max(...mVals);
        const minAprob = Math.min(...aVals); const maxAprob = Math.max(...aVals);
        const rangeMonto = (maxMonto - minMonto) || 1;
        const rangeAprob = (maxAprob - minAprob) || 1;

        // 3. Prepare Data
        const yCategories = centroidsData_copy.map(c => clusterLabels[c.cluster]);
        const mScores = mVals.map(v => Math.round(((v - minMonto) / rangeMonto) * 100));
        const aScores = aVals.map(v => Math.round(((v - minAprob) / rangeAprob) * 100));

        // 4. Traces
        // A. Connector Lines
        const connectorTraces = [];
        centroidsData_copy.forEach((c, i) => {
            connectorTraces.push({
                x: [mScores[i], aScores[i]],
                y: [yCategories[i], yCategories[i]],
                mode: 'lines',
                line: { color: '#D8DEE9', width: 2 },
                opacity: 0.6,
                showlegend: false,
                hoverinfo: 'skip'
            });
        });

        // B. Monto Dots
        const traceMonto = {
            x: mScores, y: yCategories,
            name: txt.lbl_monto,
            mode: 'markers+text',
            marker: { color: '#003366', size: 12 },
            text: mScores,
            textposition: 'middle right', 
            textfont: { size: 11, color: txtColor }, // Use theme-aware color
            texttemplate: '%{x}', // Integer only
            cliponaxis: false,
            hovertemplate: centroidsData_copy.map((c, i) => {
                return `<b>${clusterLabels[c.cluster]}</b><br>` +
                       `${txt.lbl_monto}: <b>${fmtMoney(mVals[i])}</b><br>` +
                       `Score: <b>${mScores[i]}</b><extra></extra>`;
            }),
            legendgroup: 'monto', showlegend: false
        };

        // C. Aprobaciones Dots
        const traceAprob = {
            x: aScores, y: yCategories,
            name: txt.lbl_proyectos,
            mode: 'markers+text',
            marker: { color: '#198754', size: 12 },
            text: aScores,
            textposition: 'middle right', 
            textfont: { size: 11, color: txtColor }, // Use theme-aware color
            texttemplate: '%{x}', // Integer only
            cliponaxis: false,
            hovertemplate: centroidsData_copy.map((c, i) => {
                return `<b>${clusterLabels[c.cluster]}</b><br>` +
                       `${txt.lbl_proyectos}: <b>${Math.round(aVals[i])}</b><br>` +
                       `Score: <b>${aScores[i]}</b><extra></extra>`;
            }),
            legendgroup: 'aprob', showlegend: false
        };

        // D. Special Legend Traces (No text, avoids 'Aa')
        const firstCat = yCategories[0];
        const legMonto = { x: [null], y: [firstCat], mode:'markers', marker:{color:'#003366', size:10}, name: txt.lbl_monto, showlegend: true, legendgroup:'monto' };
        const legAprob = { x: [null], y: [firstCat], mode:'markers', marker:{color:'#198754', size:10}, name: txt.lbl_proyectos, showlegend: true, legendgroup:'aprob' };

        // E. Quick Reading Annotations (Right Side - Aligned Column)
        const rowDescs = centroidsData_copy.map((c, i) => {
            const label = clusterLabels[c.cluster];
            if(label.includes('Estrat√©gico') || label.includes('Strategic')) return txt.desc_estr;
            if(label.includes('Regular')) return txt.desc_regu;
            return txt.desc_meno;
        });

        const annotations = rowDescs.map((desc, i) => ({
            xref: 'paper', x: 1.10, yref: 'y', y: yCategories[i],
            text: `<i style="color:${txtColor}; opacity:0.6; font-size:11px;">${desc}</i>`,
            showarrow: false, xanchor: 'left', yanchor: 'middle'
        }));

        Plotly.newPlot('radar-chart', [...connectorTraces, traceMonto, traceAprob, legMonto, legAprob], {
            margin: {t:40, b:40, l:150, r:250}, 
            paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
            font: { family: 'Inter', color: txtColor },
            showlegend: true,
            legend: {orientation: 'h', y: 1.25, x: 0.5, xanchor:'center', font: {size: 11}}, 
            xaxis: {
                range: [-15, 120], 
                tickvals: [0, 25, 50, 75, 100],
                showgrid: true, 
                gridcolor: currentTheme === 'light' ? 'rgba(0,0,0,0.1)' : 'rgba(255,255,255,0.1)',
                gridwidth: 1, 
                zeroline: false,
                tickfont: {color: txtColor}
            },
            yaxis: {
                showgrid: false, 
                tickfont: {size: 12, weight: 600, color: txtColor},
                automargin: true
            },
            shapes: [
                {
                    type: 'line', xref: 'x', x0: 50, x1: 50, yref: 'paper', y0: 0, y1: 1,
                    line: { color: currentTheme === 'light' ? '#999' : '#fff', width: 1, dash: 'dot' }, opacity: 0.2
                }
            ],
            annotations: annotations
        }, {displayModeBar: false});
    }

    // --- TOGGLES ---
    function toggleTheme() {
        currentTheme = currentTheme === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', currentTheme);
        document.getElementById('btn-theme').classList.toggle('active');
        renderCharts();
    }

    function toggleLang() {
        currentLang = currentLang === 'es' ? 'en' : 'es';
        document.getElementById('btn-lang').classList.toggle('active');
        updateClusterLabels();
        updateText();
        renderCharts();
        renderTable();
        renderMatrix();
    }

    function updateText() {
        const t = langData[currentLang];
        document.querySelectorAll('[data-key]').forEach(el => {
            const key = el.getAttribute('data-key');
            if(t[key]) el.innerText = t[key];
        });
        document.getElementById('lbl-theme-light').innerText = t.txt_theme_light;
        document.getElementById('lbl-theme-dark').innerText = t.txt_theme_dark;
        document.getElementById('lbl-lang-es').innerText = t.txt_lang_es;
        document.getElementById('lbl-lang-en').innerText = t.txt_lang_en;
        document.getElementById('btn-snap-txt').innerText = t.txt_snap;
        document.getElementById('btn-pdf-txt').innerText = t.txt_pdf;
    }

    // --- ACTIONS ---
    async function takeScreenshot() {
        const btn = document.getElementById('btn-snap-txt');
        const orig = btn.innerText;
        btn.innerText = '...';
        try {
            const canvas = await html2canvas(document.body, {useCORS: true});
            const link = document.createElement('a');
            link.download = `Snapshot_KMeans_${new Date().toISOString().slice(0,19)}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        } catch(e) { console.error(e); alert('Error'); }
        btn.innerText = orig;
    }

    async function generatePDF() {
        const { jsPDF } = window.jspdf;
        const btn = document.getElementById('btn-pdf-txt');
        const orig = btn.innerText;
        btn.innerText = '...';
        
        try {
            const canvas = await html2canvas(document.body, {scale: 1, useCORS: true});
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            const imgWidth = canvas.width;
            const imgHeight = canvas.height;
            const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);
            
            pdf.addImage(imgData, 'PNG', 0, 0, imgWidth * ratio, imgHeight * ratio);
            pdf.save('Report_KMeans.pdf');
        } catch(e) { console.error(e); alert('Error PDF'); }
        btn.innerText = orig;
    }

    init();
</script>
</body>
</html>
