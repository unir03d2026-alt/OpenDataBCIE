<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tablero de Clustering (K-Medoids / PAM) - BCIE</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    
<style>
    :root { 
        --font-main: 'Inter', sans-serif;
        --primary: #105682; --text-dark: #1e293b; --text-light: #64748b; --bg-body: #f8fafc; --bg-card: #ffffff; --border: #e2e8f0; --hover: #f1f5f9; --success: #10b981; --danger: #ef4444; --tooltip-bg: #1e293b; --tooltip-text: #ffffff;
    }
    [data-theme="dark"] { 
        --primary: #38bdf8; --text-dark: #f1f5f9; --text-light: #94a3b8; --bg-body: #0f172a; --bg-card: #1e293b; --border: #334155; --hover: #334155; --tooltip-bg: #ffffff; --tooltip-text: #0f172a; 
    }
    * { box-sizing: border-box; }
    body { font-family: var(--font-main); background: var(--bg-body); margin: 0; padding: 0; color: var(--text-dark); transition: background 0.3s; }
    
    /* NAV (Exact match to Prophet) */
    .top-nav { position: fixed; top: 0; left: 0; right: 0; height: 80px; background: var(--bg-card); border-bottom: 5px solid var(--primary); display: flex; align-items: center; justify-content: space-between; padding: 0 30px; z-index: 50; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
    .header-title h1 { margin: 0; font-size: 24px; font-weight: 800; color: var(--primary); }
    .header-title .subtitle { font-size: 14px; color: var(--text-light); margin-top: 4px; }
    
    .nav-controls { display: flex; align-items: center; gap: 15px; }
    .update-badge { font-size: 11px; background: var(--hover); color: var(--text-light); padding: 5px 10px; border-radius: 4px; }

    /* TOGGLES (Exact match) */
    .toggle-wrapper { display: flex; flex-direction: column; align-items: center; gap: 4px; }
    .toggle-switch { position: relative; width: 80px; height: 30px; background: var(--bg-body); border: 1px solid var(--border); border-radius: 15px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; padding: 2px; transition: background 0.3s; }
    .toggle-switch.active { background: #94a3b8; border-color: #94a3b8; }
    .toggle-knob { width: 24px; height: 24px; background: white; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.2); transition: transform 0.3s; position: absolute; left: 3px; z-index: 2; }
    .toggle-switch.active .toggle-knob { transform: translateX(50px); }
    .toggle-icon { font-size: 14px; z-index: 1; margin: 0 8px; user-select: none; }
    .toggle-labels { display: flex; justify-content: space-between; width: 100%; font-size: 9px; font-weight: 700; color: var(--text-light); padding: 0 6px; }
    .toggle-labels span { flex: 1; text-align: center; }

    /* BUTTONS (Exact match) */
    .btn-action { font-family: var(--font-main); padding: 6px 16px; border-radius: 6px; font-size: 13px; font-weight: 700; cursor: pointer; border: 1px solid transparent; transition: 0.2s; min-width: 100px; text-align: center; }
    .btn-ghost-primary { background: transparent; border: 1px solid var(--primary); color: var(--primary); }
    .btn-ghost-primary:hover { background: var(--hover); }
    .btn-solid-primary { background: var(--primary); border: 1px solid var(--primary); color: white; }
    .btn-solid-primary:hover { opacity: 0.9; }
    
    [data-theme="dark"] .btn-ghost-primary { border-color: var(--primary); color: var(--primary); }
    [data-theme="dark"] .btn-solid-primary { color: #0f172a; } /* Dark text on light blue */

    /* LAYOUT */
    .dashboard-container { margin-top: 85px; padding: 10px 25px; max-width: 98%; margin-left: auto; margin-right: auto; display: flex; flex-direction: column; gap: 12px; }
    
    .insight-cards-container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 10px; }
    .insight-card { background: var(--bg-card); border: 1px solid var(--border); border-left: 6px solid var(--primary); border-radius: 8px; padding: 15px 20px; display: flex; flex-direction: column; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); min-height: 100px; transition: 0.2s; }
    .insight-card:hover { transform: translateY(-2px); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); }
    .insight-card-title { font-size: 13px; font-weight: 800; color: var(--text-light); text-transform: uppercase; margin-bottom: 8px; }
    .insight-card-main { display: flex; justify-content: space-between; align-items: baseline; }
    .insight-card-val { font-size: 26px; font-weight: 800; }
    .insight-card-pct { font-size: 14px; font-weight: 700; color: var(--text-light); }
    .insight-card-footer { font-size: 11px; margin-top: 5px; color: var(--text-light); display: flex; justify-content: space-between; border-top: 1px solid var(--hover); padding-top: 6px; }

    .dashboard-grid-main { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; height: calc(100vh - 380px); overflow: hidden; }

    .left-col { display: flex; flex-direction: column; gap: 20px; height: 100%; overflow: hidden; }
    .mid-col { height: 100%; overflow: hidden; display: flex; flex-direction: column; gap: 20px; }
    .right-col { height: 100%; overflow: hidden; display: flex; flex-direction: column; gap: 20px; }
    
    .card { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; box-shadow: 0 4px 6px -1px rgba(0,0,0,0.05); display: flex; flex-direction: column; overflow: hidden; }
    .card:hover { border-color: var(--primary); }
    .card-title { font-size: 13px; font-weight: 700; color: var(--primary); margin: 0 0 8px 0; border-bottom: 2px solid var(--hover); padding-bottom: 6px; display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
    
    /* MODAL */
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; backdrop-filter: blur(4px); }
    .modal-content { background: var(--bg-card); width: 600px; padding: 40px; border-radius: 20px; border: 2px solid var(--primary); box-shadow: 0 20px 50px rgba(0,0,0,0.5); position: relative; }
    .modal-content h2 { margin-top: 0; color: var(--primary); }
    .modal-body { font-size: 14px; line-height: 1.6; color: var(--text-dark); margin: 20px 0; }
    .modal-body b { color: var(--primary); }
    .modal-body ul { padding-left: 20px; }
    
    /* BADGES */
    .conf-badge { display: inline-block; padding: 2px 8px; border-radius: 4px; font-weight: 700; font-size: 10px; color: white; background: #94a3b8; }
    .conf-high { background: var(--success); }
    .conf-med { background: #f59e0b; }
    .conf-low { background: var(--danger); }

    .cluster-tag { display: inline-block; padding: 4px 10px; border-radius: 4px; color: white; font-weight: 700; font-size: 10px; white-space: nowrap; min-width: 140px; text-align: center; }
    .tag-menores { background-color: #f59e0b; color: white; } /* Amarillo */
    .tag-regulares { background-color: #10b981; color: white; } /* Verde */
    .tag-estrategicos { background-color: #105682; color: white; } /* Azul Estrategico */

    .btn-outline { background: transparent; border: 1px solid var(--border); color: var(--text-light); font-size: 11px; padding: 5px 15px; border-radius: 4px; cursor: pointer; transition: 0.2s; }
    .btn-outline:hover { border-color: var(--primary); color: var(--primary); background: var(--hover); }

    .footer-legal { font-size: 11px; color: var(--text-light); margin-bottom: 4px; text-align: center; }
    .footer-disclaimer { font-size: 11px; color: var(--text-light); opacity: 0.8; text-align: center; }

    /* KPIS & TABLE */
    .kpi-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 12px; height: 100%; }
    .kpi-box { background: var(--bg-card); border: 1px solid var(--border); border-radius: 12px; padding: 12px; display: flex; flex-direction: column; justify-content: center; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.05); min-height: 90px; flex: 1; }
    .kpi-val { font-size: 24px; font-weight: 800; color: var(--primary); }
    .kpi-lbl { font-size: 10px; font-weight: 700; color: var(--text-light); text-transform: uppercase; margin-top: 3px; }

    .table-container { flex: 1; overflow: auto; border: 1px solid var(--border); border-radius: 8px; }
    table { width: 100%; border-collapse: collapse; font-size: 11px; }
    th { text-align: left; padding: 10px; background: var(--hover); position: sticky; top: 0; border-bottom: 2px solid var(--primary); z-index: 10; }
    td { padding: 6px 10px; border-bottom: 1px solid var(--border); }

    footer { grid-column: 1 / -1; margin-top: 5px; border-top: 1px solid var(--border); padding: 5px; display: flex; flex-direction: column; align-items: center; }

    /* CUSTOM LEGEND */
    .custom-legend { display: flex; flex-direction: column; gap: 8px; margin: 5px 0 15px 0; flex-shrink: 0; }
    .legend-row { display: flex; justify-content: center; gap: 25px; flex-wrap: wrap; }
    .legend-item { display: flex; align-items: center; gap: 8px; font-size: 11px; font-weight: 600; color: var(--text-dark); }

    /* CUSTOM TOOLTIP - Minimalist & Premium */
    [data-tooltip] { position: relative; cursor: default; border-bottom: 1px dotted rgba(0,0,0,0.2); }
    [data-tooltip]:after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 110%;
        left: 50%;
        transform: translateX(-50%) translateY(4px);
        
        background: rgba(15, 23, 42, 0.95); /* Slate 900 */
        color: #f8fafc;
        border: 1px solid rgba(255,255,255,0.1);
        backdrop-filter: blur(4px);
        
        padding: 8px 12px;
        border-radius: 6px;
        font-family: 'Inter', sans-serif;
        font-size: 11px;
        line-height: 1.4;
        font-weight: 500;
        text-align: center;
        white-space: normal;
        min-width: 220px;
        max-width: 280px;
        
        opacity: 0;
        visibility: hidden;
        pointer-events: none;
        transition: all 0.15s cubic-bezier(0.16, 1, 0.3, 1);
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        z-index: 1000;
    }
    [data-tooltip]:hover:after { 
        opacity: 1; 
        visibility: visible;
        transform: translateX(-50%) translateY(0);
    }
    
    /* Info Icon style */
    .icon-info { display: inline-flex; justify-content: center; align-items: center; width: 14px; height: 14px; border-radius: 50%; border: 1px solid currentColor; font-size: 9px; margin-left: 4px; opacity: 0.6; }
    /* Badge Status */
    .badge-status { font-size:11px; font-weight:bold; margin-top:4px; text-transform:uppercase; letter-spacing:0.5px; }
</style>
</head>
<body id="dashboard-body">
    <nav class="top-nav">
        <div class="header-title">
            <h1 data-key="title" id="lbl-main">Dashboard de Clustering (K-Medoids)</h1>
            <div class="subtitle">
                <span data-key="subtitle" id="lbl-sub">Segmentaci√≥n de Pa√≠ses BCIE</span>
                <span style="margin: 0 10px; opacity: 0.3;">|</span>
                <span data-key="purpose_text" style="font-weight: 400; font-size: 13px; opacity: 0.8;">Modelo para identificar patrones de inversi√≥n y frecuencia operativa.</span>
                <div data-key="model_context" style="font-size: 10px; color: var(--text-light); margin-top: 2px;">k=3 | Variables: Monto (log) + Aprobaciones | Algoritmo: PAM</div>
            </div>
        </div>
        <div class="nav-controls">
            <div style="display:flex; gap:10px; align-items: center; margin-right:15px">
                <button id="btn-insights" class="btn-action btn-ghost-primary" style="min-width:120px;" data-key="btn_insights" onclick="toggleInsights(true)">Insights</button>
                <div style="width:1px; height:20px; background:var(--border); margin: 0 5px;"></div>
                <button id="btn-metrics" class="btn-action btn-ghost-primary" style="min-width:120px;" data-key="btn_metrics" onclick="toggleMetrics(true)">M√©tricas</button>
                <div style="width:1px; height:20px; background:var(--border); margin: 0 5px;"></div>
                <button id="btn-method" class="btn-action btn-ghost-primary" style="min-width:120px;" data-key="btn_method" onclick="toggleModal(true)">Metodolog√≠a</button>
                <div style="width:1px; height:20px; background:var(--border); margin: 0 5px;"></div>
                <button class="btn-action btn-ghost-primary" onclick="takeScreenshot()">
                    <span id="btn-snap-txt">Captura</span>
                </button>
                <button class="btn-action btn-solid-primary" onclick="generatePDF()">
                    <span id="btn-pdf-txt">PDF</span>
                </button>
            </div>
            
            <div class="update-badge" id="lbl-update">Datos Actualizados: {{UPDATE_TIME}}</div>
            
            <!-- THEME TOGGLE -->
            <div class="toggle-wrapper">
                <div class="toggle-switch" id="btn-theme" onclick="toggleTheme()" title="Tema">
                    <div class="toggle-knob"></div>
                    <span class="toggle-icon">‚òÄÔ∏è</span>
                    <span class="toggle-icon">üåô</span>
                </div>
                <div class="toggle-labels">
                    <span id="lbl-theme-light">Claro</span>
                    <span id="lbl-theme-dark">Oscuro</span>
                </div>
            </div>

            <!-- LANG TOGGLE -->
            <div class="toggle-wrapper">
                <div class="toggle-switch" id="btn-lang" onclick="toggleLang()" title="Idioma">
                    <div class="toggle-knob"></div>
                </div>
                <div class="toggle-labels">
                    <span id="lbl-lang-es">Esp</span>
                    <span id="lbl-lang-en">Ing</span>
                </div>
            </div>
        </div>
    </nav>
    <div class="dashboard-container">
        <!-- TOP SECTION: INSIGHT CARDS -->
        <div id="segment-cards" class="insight-cards-container">
            <!-- Dynamic Cards for Each Segment -->
        </div>

        <div class="dashboard-grid-main">
            <!-- LEFT COLUMN: GRAPHS ONLY -->
            <div class="left-col">
                <!-- ELBOW CHART (Fixed Height) -->
                <div class="card" style="flex: 0 0 320px;">
                    <h3 class="card-title">
                        <span data-key="elbow_title">Optimizaci√≥n de K (Codo)</span>
                    </h3>
                    <div id="elbow-chart" class="chart-container" style="height: 100%;"></div>
                </div>

                <!-- SCATTER CHART (Flex Fill) -->
                <div class="card" style="flex: 1; display:flex; flex-direction:column; overflow:hidden;">
                    <h3 class="card-title">
                        <span data-key="scatter_title">Segmentaci√≥n de Pa√≠ses</span>
                        <span data-key="scatter_subtitle" style="font-size:11px; font-weight:400; color:var(--text-light);">Monto vs Aprobaciones (Elipses de Confianza 95%)</span>
                    </h3>
                    <div id="scatter-legend" class="custom-legend"></div>
                    <div id="scatter-chart" class="chart-container" style="flex:1; min-height:0;"></div>
                </div>
            </div>

            <!-- MIDDLE COLUMN: KPIS + TABLE -->
            <div class="mid-col">
                <!-- KPIS -->
                <div class="card" style="flex: 0 0 auto;">
                    <h3 class="card-title" data-key="kpi_title">Resumen General</h3>
                    <div class="kpi-grid">
                        <div class="kpi-box">
                            <div class="kpi-lbl" data-key="kpi_countries">Registros</div>
                            <div class="kpi-val" id="kpi-countries">0</div>
                        </div>
                        <div class="kpi-box">
                            <div class="kpi-lbl" data-key="kpi_clusters">Clusters</div>
                            <div class="kpi-val" id="kpi-k">0</div>
                        </div>
                        <div class="kpi-box">
                            <div class="kpi-lbl" data-key="kpi_sil">Calidad del Modelo</div>
                            <div class="kpi-val" id="kpi-score" style="font-size:18px;">0.00</div>
                            <div id="kpi-health-lbl" style="font-size:11px; margin-top:4px; font-weight:bold; cursor:help;">-</div>
                        </div>
                         <div class="kpi-box">
                            <div class="kpi-lbl" data-key="kpi_amount">Monto Total</div>
                            <div class="kpi-val" id="kpi-total-monto" style="font-size:18px;">$0</div>
                        </div>
                    </div>
                </div>

                <!-- TABLE -->
                <div class="card" style="flex: 1; overflow: hidden;">
                    <h3 class="card-title" data-key="table_title">Detalle de Segmentos</h3>
                    <div class="table-container">
                        <table id="data-table">
                            <thead>
                                <tr>
                                    <th data-key="col_year">A√±o</th>
                                    <th data-key="col_country">Pa√≠s</th>
                                    <th data-key="col_amount">Monto</th>
                                    <th data-key="col_count">Aprob.</th>
                                    <th data-key="col_sector">Sector</th>
                                    <th data-key="col_conf">Ajuste</th>
                                    <th data-key="col_cluster">Segmento</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- RIGHT COLUMN: PROFILE + MATRIX -->
            <div class="right-col">
                <!-- RADAR CHART (PROFILE) -->
                <div class="card" style="flex: 1; min-height: 0; display:flex; flex-direction:column; overflow: hidden;">
                    <h3 class="card-title">
                        <span data-key="radar_title">Perfil por Segmento (Score 0‚Äì100)</span>
                    </h3>
                    <div id="radar-chart" class="chart-container" style="flex:1; min-height:0;"></div>
                </div>

                <!-- MATRIX -->
                <div class="card" style="flex: 0 0 auto;">
                    <h3 class="card-title">
                        <span data-key="matrix_title">Matriz de Segmentos</span>
                        <span data-key="matrix_subtitle" style="font-size:11px; font-weight:400; color:var(--text-light);">Conteo por Pa√≠s</span>
                    </h3>
                    <div class="table-container" style="height: auto; max-height: 500px; overflow: auto;">
                        <table id="matrix-table">
                            <thead>
                                <tr id="matrix-header">
                                    <th>Pa√≠s</th>
                                    <!-- Columns injected by JS -->
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <div data-key="footer_legal" class="footer-legal">¬© 2026 | UNIR‚ÄìBCIE | Trabajo de Colaboraci√≥n Acad√©mica | Equipo 03-D | Todos los derechos reservados.</div>
            <div data-key="footer_disclaimer" class="footer-disclaimer">Los resultados son para fines acad√©micos y no constituyen compromiso financiero vinculante por parte del BCIE.</div>
        </footer>

    </div>

    <!-- METHODOLOGY MODAL -->
    <div id="method-modal" class="modal-overlay" style="display:none;">
        <div class="modal-content">
            <h2 data-key="method_title">Metodolog√≠a de Segmentaci√≥n</h2>
            <div class="modal-body" data-key="method_body">
                <!-- Content via langData -->
            </div>
            <button class="btn btn-primary" onclick="toggleModal(false)">Cerrar</button>
        </div>
    </div>

    <!-- STRATEGIC INSIGHTS MODAL -->
    <div id="insights-modal" class="modal-overlay" style="display:none;">
        <div class="modal-content" style="max-width: 700px;">
            <h2 data-key="insights_title" style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">Key Insights del An√°lisis</h2>
            <div class="modal-body">
                <div style="margin-bottom: 20px;">
                    <h4 data-key="insights_p1_t" style="margin-bottom: 8px;">üî• 1. CONCENTRACI√ìN DE VALOR EXTREMA</h4>
                    <p data-key="insights_p1_b" style="font-size: 14px; line-height: 1.5; color: var(--text-dark);"></p>
                </div>
                <div style="margin-bottom: 20px;">
                    <h4 data-key="insights_p2_t" style="margin-bottom: 8px;">üåé 2. LIDERAZGO REGIONAL DIFERENCIADO</h4>
                    <p data-key="insights_p2_b" style="font-size: 14px; line-height: 1.5; color: var(--text-dark);"></p>
                </div>
                <div style="margin-bottom: 20px;">
                    <h4 data-key="insights_p3_t" style="margin-bottom: 8px;">üìà 3. EFICIENCIA OPERATIVA EVIDENTE</h4>
                    <p data-key="insights_p3_b" style="font-size: 14px; line-height: 1.5; color: var(--text-dark);"></p>
                </div>
            </div>
            <button class="btn btn-primary" onclick="toggleInsights(false)">Cerrar</button>
        </div>
    </div>

    <!-- METRICS MODAL -->
    <div id="metrics-modal" class="modal-overlay" style="display:none;">
        <div class="modal-content" style="max-width: 600px;">
            <h2 data-key="metrics_title" style="color: var(--primary); border-bottom: 2px solid var(--primary); padding-bottom: 10px;">M√©tricas Avanzadas</h2>
            <div class="modal-body">
                <p data-key="metrics_intro" style="margin-bottom:20px; color:var(--text-light); font-size:13px;">Estas m√©tricas eval√∫an la calidad t√©cnica y estabilidad del agrupamiento.</p>
                
                <div style="font-size:11px; color:var(--text-light); margin-bottom:15px; text-align:right; border-bottom:1px solid var(--border); padding-bottom:5px;">
                    <span style="float:left; font-weight:600;">METRICS DASHBOARD</span>
                    <span data-key="metrics_header_sub">Bootstrap (N=20)</span>
                </div>
                
                <!-- ROW 1: SILHOUETTE | DBI -->
                <div class="kpi-grid" style="grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom:15px;">
                    <!-- Silhouette -->
                    <div class="kpi-box" style="align-items:flex-start; padding:15px;">
                        <div class="kpi-lbl"><span data-key="lbl_sil">Silhouette Score (‚Üë mejor)</span> <span class="icon-info" data-key-tooltip="tip_sil" data-tooltip="[-1, 1]">i</span></div>
                        <div class="kpi-val" id="adv-sil">0.0000</div>
                        <div style="font-size:10px; color:var(--text-light); margin-top:2px;">(<span data-key="lbl_mean_std">Media ¬± Std</span>: <span id="adv-sil-stats">0.000 ¬± 0.000</span>)</div>
                        <div id="adv-sil-lbl" class="badge-status">N/A</div>
                        <div style="font-size:10px; color:var(--danger); margin-top:4px;"><span data-key="lbl_neg">Silhouette < 0</span>: <span id="adv-sil-neg">0.2%</span> <span data-key="lbl_neg_text" style="font-style:italic;">(posibles asignaciones d√©biles)</span></div>
                    </div>
                    <!-- Davies-Bouldin -->
                    <div class="kpi-box" style="align-items:flex-start; padding:15px;">
                        <div class="kpi-lbl"><span data-key="lbl_dbi">Davies-Bouldin (‚Üì mejor)</span> <span class="icon-info" data-key-tooltip="tip_dbi" data-tooltip="0+">i</span></div>
                        <div class="kpi-val" id="adv-dbi">0.0000</div>
                        <div style="font-size:10px; color:var(--text-light); margin-top:2px;">(<span data-key="lbl_mean_std">Media ¬± Std</span>: <span id="adv-dbi-stats">0.000 ¬± 0.000</span>)</div>
                        <div id="adv-dbi-lbl" class="badge-status">N/A</div>
                    </div>
                </div>

                <!-- ROW 2: CALINSKI | STABILITY -->
                <div class="kpi-grid" style="grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom:15px;">
                    <!-- Calinski-Harabasz -->
                    <div class="kpi-box" style="align-items:flex-start; padding:15px;">
                        <div class="kpi-lbl"><span data-key="lbl_ch">Calinski-Harabasz (‚Üë mejor)</span> <span class="icon-info" data-key-tooltip="tip_ch" data-tooltip="‚Üë mejor (comparativo)">i</span></div>
                        <div class="kpi-val" id="adv-ch">0.0</div>
                    </div>
                    <!-- Stability -->
                    <div class="kpi-box" style="align-items:flex-start; padding:15px;">
                        <div class="kpi-lbl"><span data-key="lbl_ari">Estabilidad (ARI, Bootstrap N=20)</span> <span class="icon-info" data-key-tooltip="tip_ari" data-tooltip="0‚Äì1">i</span></div>
                        <div class="kpi-val" id="adv-ari">0.0000</div>
                        <div style="font-size:10px; color:var(--text-light); margin-top:2px;"><span data-key="lbl_range">Rango</span>: <span id="adv-ari-range">0.00 - 0.00</span></div>
                        <div id="adv-ari-badge" style="display:none; margin-top:4px; font-size:10px; background:#fef3c7; color:#b45309; padding:2px 6px; border-radius:4px;">‚ö†Ô∏è <span data-key="badge_check">Revisar M√©todo</span></div>
                    </div>
                </div>
                
                <h4 style="margin: 20px 0 10px 0; font-size: 13px; color: var(--text-light); text-transform: uppercase; letter-spacing: 0.5px; border-top:1px solid var(--border); padding-top:10px;" data-key="diag_title">Diagn√≥stico de Segmentaci√≥n</h4>
                
                <!-- ROW 3: BALANCE | ITERATIONS -->
                <div class="kpi-grid" style="grid-template-columns: 1fr 1fr; gap: 15px;">
                     <!-- Cluster Balance -->
                     <div class="kpi-box" style="align-items:flex-start; padding:15px;">
                        <div class="kpi-lbl"><span data-key="lbl_bal">Balance (CV tama√±os)</span> <span class="icon-info" data-key-tooltip="tip_bal" data-tooltip="0+">i</span></div>
                        <div class="kpi-val" id="adv-cv">0.00</div>
                        <div id="adv-cv-lbl" class="badge-status">N/A</div>
                        <div style="font-size:10px; color:var(--text-light); margin-top:2px;">Min: <span id="adv-min">0%</span> | Max: <span id="adv-max">0%</span></div>
                        <div style="font-size:10px; color:var(--primary); margin-top:2px; white-space:nowrap;"><span data-key="lbl_sizes">Tama√±o clusters</span>: <span id="adv-sizes">0/0/0</span></div>
                    </div>
                    <!-- Iterations -->
                    <div class="kpi-box" style="align-items:flex-start; padding:15px;">
                        <div class="kpi-lbl"><span data-key="lbl_iner">WCSS / Inercia (‚Üì mejor)</span> <span class="icon-info" data-key-tooltip="tip_iner" data-tooltip="‚Üì mejor">i</span></div>
                        <div style="font-size:18px; font-weight:700; color:var(--text-dark);">
                            <span id="adv-iter">0</span> <span data-key="txt_iters" style="font-size:13px;font-weight:400;"></span>
                        </div>
                        <div style="font-size:11px; color:var(--text-light);">Total: <span id="adv-inertia">0</span></div>
                         <div style="font-size:11px; color:var(--text-light); margin-top:1px;">WCSS/N: <span id="adv-inertia-per-point">0</span></div>
                    </div>
                </div>
            </div>
            
            <div style="display:flex; justify-content:flex-end; margin-top:20px; border-top:1px solid var(--border); padding-top:10px;">
                <button class="btn btn-outline" style="border-color:var(--primary); color:var(--primary);" onclick="toggleMetrics(false)">Cerrar</button>
            </div>
        </div>
    </div>

<script>
    // INJECTED DATA
    const dataClusters = JSON.parse('{{DATA_CLUSTERS}}');
    const metricsData = JSON.parse('{{DATA_METRICS}}');
    const advancedMetrics = JSON.parse('{{DATA_ADVANCED_METRICS}}');
    const centroidsData = JSON.parse('{{DATA_CENTROIDS}}');
    
    // CLUSTER NAMING LOGIC
    // Sort centroids by Amount to determine hierarchy
    const sortedCentroids = [...centroidsData].sort((a, b) => a.monto - b.monto);
    const clusterLabels = {};
    const rankColors = ['#f59e0b', '#10b981', '#105682']; 
    const clusterColorMap = {};
    
    // Assign names and Build Color Map globally for Table usage
    sortedCentroids.forEach((c, index) => {
        let label = `Cluster ${c.cluster}`;
        if (sortedCentroids.length === 3) {
            if (index === 0) label = "Proyectos Menores";     // Lowest Amount
            if (index === 1) label = "Proyectos Regulares";   // Mid Amount
            if (index === 2) label = "Estrat√©gicos";          // High Amount
        }
        clusterLabels[c.cluster] = label;
        clusterColorMap[c.cluster] = rankColors[index];
    });

    // LANGUAGE DICTIONARY
    const langData = {
        es: {
            title: "Dashboard de Clustering (K-Medoids)",
            subtitle: "Segmentaci√≥n Inteligente de Pa√≠ses BCIE",
            elbow_title: "Validaci√≥n (Codo + Silueta)",
            scatter_title: "Mapa de Segmentaci√≥n",
            scatter_subtitle: "Monto vs Aprobaciones (Elipses de Confianza 95%)",
            radar_title: "Perfil por Segmento (Score 0‚Äì100)",
            radar_subtitle: "Comparaci√≥n relativa: Monto vs # de Proyectos (centroides)",
            matrix_title: "Matriz de Segmentos",
            matrix_subtitle: "Conteo por Pa√≠s",
            kpi_title: "Resumen General",
            kpi_countries: "Registros",
            kpi_clusters: "Clusters",
            kpi_sil: "Calidad del Modelo",
            kpi_amount: "Monto Total",
            table_title: "Detalle de Segmentos",
            col_country: "Pa√≠s",
            col_year: "A√±o",
            col_amount: "Monto",
            col_cluster: "Segmento",
            col_count: "Aprobaciones",
            col_sector: "Sector",
            col_conf: "Ajuste",
            lbl_monto: "Monto",
            lbl_proyectos: "Proyectos",
            lbl_ops: "Operaciones",
            lbl_vol: "Volumen",
            desc_estr: "Monto alto / Proyectos bajos",
            desc_regu: "Monto medio / Proyectos altos",
            desc_meno: "Monto bajo / Proyectos bajos",
            txt_total_general: "TOTAL GENERAL",
            txt_theme_light: "Claro", txt_theme_dark: "Oscuro",
            txt_lang_es: "Esp", txt_lang_en: "Ing",
            txt_snap: "Captura", txt_pdf: "PDF",
            btn_method: "Metodolog√≠a",
            lbl_operativity: "Operatividad",
            xaxis_monto: "Escala Logar√≠tmica (Monto)",
            purpose_text: "Modelo para identificar patrones de inversi√≥n y frecuencia operativa.",
            method_title: "Metodolog√≠a de Segmentaci√≥n",
            btn_insights: "An√°lisis Estrat√©gico",
            btn_metrics: "M√©tricas Modelo",
            metrics_title: "M√©tricas de Validaci√≥n",
            metrics_intro: "Evaluaci√≥n t√©cnica de la calidad utilizando medoides reales como centros (Cohesi√≥n, Separaci√≥n).",
            tip_health: "Mide qu√© tan bien est√°n separados los clusters. > 0.5 indica una estructura s√≥lida.",
            tip_oper: "Operatividad = (Aprobaciones / Monto) √ó 100. Mide eficiencia en procesos (m√°s alto = mejor).",
            insights_title: "Key Insights del An√°lisis",
            insights_p1_t: "üî• 1. CONCENTRACI√ìN DE VALOR EXTREMA",
            insights_p1_b: "El 89% del monto ($50.9B) se concentra en el 50% de las operaciones (Estrat√©gicos). Esto revela una estrategia dual: grandes apuestas de impacto junto a peque√±as victorias de desarrollo. Pareto intensificado (89/50).",
            insights_p2_t: "üåé 2. LIDERAZGO REGIONAL DIFERENCIADO",
            insights_p2_b: "Costa Rica lidera en megaproyectos transformadores, mientras Honduras muestra una distribuci√≥n balanceada y Guatemala destaca en proyectos menores de desarrollo local. Perfiles pa√≠s-espec√≠ficos exitosos.",
            insights_p3_t: "üìà 3. EFICIENCIA OPERATIVA EVIDENTE",
            insights_p3_b: "Los proyectos estrat√©gicos logran el mismo impacto financiero con 4-8 veces menos tr√°mites administrativos que los menores. Valida la focalizaci√≥n en grandes inversiones para optimizar el capital.",
            method_body: `
                <p>Este modelo utiliza el algoritmo <b>K-Medoids (PAM)</b> para agrupar las operaciones del BCIE, utilizando puntos de datos reales (medoides) como centros en lugar de promedios:</p>
                <ul>
                    <li><b>Monto Aprobado:</b> Transformado a escala logar√≠tmica para manejar la alta volatilidad de los datos.</li>
                    <li><b>N√∫mero de Aprobaciones:</b> Frecuencia operativa por pa√≠s y a√±o.</li>
                </ul>
                <p><b>Ajuste de Segmento:</b> Calculado como la inversa de la distancia Manhattan al medoide, normalizado de 0 a 100%.</p>
                <p><b>Elipses:</b> Representan el √°rea de confianza del 95% para cada distribuci√≥n de segmento.</p>
            `,
            health_labels: ["Pobre", "Moderada", "Buena", "Excelente"],
            footer_legal: "¬© 2026 | UNIR‚ÄìBCIE | Trabajo de Colaboraci√≥n Acad√©mica | Equipo 03-D | Todos los derechos reservados.",
            footer_disclaimer: "Los resultados son para fines acad√©micos y no constituyen compromiso financiero vinculante por parte del BCIE.",
            // Content Maps
            sectors: { "Sector Privado": "Sector Privado", "Sector P√∫blico": "Sector P√∫blico" },
            countries: { 
                "Belice": "Belice", "M√©xico": "M√©xico", "Panam√°": "Panam√°", "Rep√∫blica Dominicana": "Rep√∫blica Dominicana", "Espa√±a": "Espa√±a",
                "Honduras": "Honduras", "Costa Rica": "Costa Rica", "Guatemala": "Guatemala", "El Salvador": "El Salvador", "Nicaragua": "Nicaragua",
                "Colombia": "Colombia", "Argentina": "Argentina", "Cuba": "Cuba", "Regional": "Regional"
            },
            clusterNames: ["Proyectos Menores", "Proyectos Regulares", "Estrat√©gicos"]
        },
        en: {
            title: "Clustering Dashboard (K-Medoids)",
            subtitle: "BCIE Country Segmentation",
            elbow_title: "Validation (Elbow + Silhouette)",
            scatter_title: "Segmentation Map",
            scatter_subtitle: "Amount vs Approvals (Robust Segmentation)",
            radar_title: "Segment Profile (Score 0‚Äì100)",
            radar_subtitle: "Relative comparison: Amount vs # of Projects (centroids)",
            matrix_title: "Segment Matrix",
            matrix_subtitle: "Counts per Country",
            kpi_title: "General Overview",
            kpi_countries: "Records",
            kpi_clusters: "Clusters (K)",
            kpi_sil: "Model Quality",
            kpi_amount: "Total Amount",
            table_title: "Segment Details",
            col_country: "Country",
            col_year: "Year",
            col_amount: "Amount",
            col_count: "Approvals",
            col_sector: "Sector",
            col_conf: "Adjustment",
            col_cluster: "Cluster",
            lbl_monto: "Amount",
            lbl_proyectos: "Projects",
            lbl_ops: "Operations",
            lbl_vol: "Volume",
            desc_estr: "High Amount / Low Projects",
            desc_regu: "Med Amount / High Projects",
            desc_meno: "Low Amount / Low Projects",
            txt_total_general: "GRAND TOTAL",
            txt_theme_light: "Light", txt_theme_dark: "Dark",
            txt_lang_es: "Esp", txt_lang_en: "Eng",
            txt_snap: "Snapshot", txt_pdf: "PDF",
            btn_method: "Methodology",
            lbl_operativity: "Operativity",
            xaxis_monto: "Logarithmic Scale (Amount)",
            purpose_text: "Model to identify investment patterns and operational frequency.",
            method_title: "Segmentation Methodology",
            btn_insights: "Strategic Insights",
            btn_metrics: "Model Metrics",
            metrics_title: "Validation Metrics",
            metrics_intro: "Technical evaluation of clustering quality (Cohesion, Separation, Stability).",
            tip_health: "Measures how well clusters are separated. > 0.5 indicates solid structure.",
            tip_oper: "Operativity = (Approvals / Amount) √ó 100. Measures process efficiency (higher = better).",
            insights_title: "Key Analysis Insights",
            insights_p1_t: "üî• 1. EXTREME VALUE CONCENTRATION",
            insights_p1_b: "89% of total amount ($50.9B) is concentrated in only 50% of operations (Strategic cluster). This reveals a dual strategy: few high-impact bets alongside many developmental wins. Intensified Pareto (89/50).",
            insights_p2_t: "üåé 2. DIFFERENTIATED REGIONAL LEADERSHIP",
            insights_p2_b: "Costa Rica leads in transformative megaprojects, while Honduras shows a balanced distribution and Guatemala excels in smaller local development wins. Successful country-specific profiles.",
            insights_p3_t: "üìà 3. EVIDENT OPERATIVE EFFICIENCY",
            insights_p3_b: "Strategic projects achieve the same financial impact with 4-8x less administrative overhead than smaller ones. This validates the focus on large-scale investments to optimize capital use.",
            method_body: `
                <p>This model uses the <b>K-Medoids (PAM)</b> algorithm to group CABEI operations, using actual data points (medoids) as centers to reduce outlier influence:</p>
                <ul>
                    <li><b>Approved Amount:</b> Log-scaled to handle high data volatility and variance.</li>
                    <li><b>Number of Approvals:</b> Operational frequency by country and year.</li>
                </ul>
                <p><b>Segment Adjustment:</b> Calculated as the inverse Manhattan distance to the medoid, normalized 0 to 100%.</p>
                <p><b>Ellipses:</b> Represent the 95% confidence area for each segment distribution.</p>
            `,
            health_labels: ["Poor", "Moderate", "Good", "Excellent"],
            footer_legal: "¬© 2026 | UNIR‚ÄìBCIE | Academic Collaboration | Team 03-D | All rights reserved.",
            footer_disclaimer: "Results are for academic purposes and do not constitute a binding financial commitment by CABEI.",
            // Content Maps
            sectors: { "Sector Privado": "Private Sector", "Sector P√∫blico": "Public Sector" },
            countries: { 
                "Belice": "Belize", "M√©xico": "Mexico", "Panam√°": "Panama", "Rep√∫blica Dominicana": "Dominican Republic", "Espa√±a": "Spain",
                "Honduras": "Honduras", "Costa Rica": "Costa Rica", "Guatemala": "Guatemala", "El Salvador": "El Salvador", "Nicaragua": "Nicaragua",
                "Colombia": "Colombia", "Argentina": "Argentina", "Cuba": "Cuba", "Regional": "Regional"
            },
            clusterNames: ["Proyectos Menores", "Proyectos Regulares", "Estrat√©gicos"],
            // Metrics
            metrics_header_sub: "Bootstrap (N=20)",
            lbl_sil: "Silhouette Score (‚Üë mejor)",
            lbl_dbi: "Davies-Bouldin (‚Üì mejor)",
            lbl_ch: "Calinski-Harabasz (‚Üë mejor)",
            lbl_ari: "Estabilidad (ARI, Bootstrap N=20)",
            lbl_bal: "Balance (CV tama√±os) (‚Üì mejor)",
            lbl_iner: "Dispersi√≥n intra-cluster (WCSS/Inercia) (‚Üì mejor)",
            diag_title: "Diagn√≥stico de Segmentaci√≥n",
            lbl_mean_std: "Media ¬± Std",
            lbl_range: "Rango",
            lbl_neg: "Silhouette < 0",
            tip_sil: "[-1, 1]",
            tip_dbi: "0+",
            tip_ch: "‚Üë mejor (comparar entre modelos con los mismos datos)",
            tip_ari: "0‚Äì1",
            tip_bal: "0+",
            tip_iner: "‚Üì mejor",
            txt_weak: "D√©bil", txt_med: "Medio", txt_strong: "Fuerte", txt_ok: "Ok",
            txt_good: "Bueno", txt_risk: "Riesgo",
            badge_check: "Revisar M√©todo",
            lbl_neg_text: "(posibles asignaciones d√©biles)",
            txt_iters: "iteraciones",
            model_context: "k=3 | Variables: log(Monto) y #Aprobaciones | Distancia: Euclidean",
            lbl_sizes: "Tama√±o Clusters"
        },
        en: {
            title: "Clustering Dashboard (K-Means)",
            subtitle: "BCIE Country Segmentation",
            elbow_title: "Validation (Elbow + Silhouette)",
            scatter_title: "Segmentation Map",
            scatter_subtitle: "Amount vs Approvals (95% Confidence Ellipses)",
            radar_title: "Segment Profile (Score 0‚Äì100)",
            radar_subtitle: "Relative comparison: Amount vs # of Projects (centroids)",
            matrix_title: "Segment Matrix",
            matrix_subtitle: "Counts per Country",
            kpi_title: "General Overview",
            kpi_countries: "Records",
            kpi_clusters: "Clusters (K)",
            kpi_sil: "Model Quality",
            kpi_amount: "Total Amount",
            table_title: "Segment Details",
            col_country: "Country",
            col_year: "Year",
            col_amount: "Amount",
            col_count: "Approvals",
            col_sector: "Sector",
            col_conf: "Adjustment",
            col_cluster: "Cluster",
            lbl_monto: "Amount",
            lbl_proyectos: "Projects",
            lbl_ops: "Operations",
            lbl_vol: "Volume",
            desc_estr: "High Amount / Low Projects",
            desc_regu: "Med Amount / High Projects",
            desc_meno: "Low Amount / Low Projects",
            txt_total_general: "GRAND TOTAL",
            txt_theme_light: "Light", txt_theme_dark: "Dark",
            txt_lang_es: "Esp", txt_lang_en: "Eng",
            txt_snap: "Snapshot", txt_pdf: "PDF",
            btn_method: "Methodology",
            lbl_operativity: "Operativity",
            xaxis_monto: "Logarithmic Scale (Amount)",
            purpose_text: "Model to identify investment patterns and operational frequency.",
            method_title: "Segmentation Methodology",
            btn_insights: "Strategic Insights",
            btn_metrics: "Model Metrics",
            metrics_title: "Clustering Validation Metrics",
            metrics_intro: "Technical quality assessment: Cohesion, Separation and Stability.",
            tip_health: "Measures how well clusters are separated. > 0.5 indicates solid structure.",
            tip_oper: "Operatividad = (Apr / Amt) * 100. Measures efficiency.",
            insights_title: "Key Analysis Insights",
            insights_p1_t: "üî• 1. EXTREME VALUE CONCENTRATION",
            insights_p1_b: "89% of total amount ($50.9B) is concentrated in only 50% of operations (Strategic cluster). This reveals a dual strategy: few high-impact bets alongside many developmental wins. Intensified Pareto (89/50).",
            insights_p2_t: "üåé 2. DIFFERENTIATED REGIONAL LEADERSHIP",
            insights_p2_b: "Costa Rica leads in transformative megaprojects, while Honduras shows a balanced distribution and Guatemala excels in smaller local development wins. Successful country-specific profiles.",
            insights_p3_t: "üìà 3. EVIDENT OPERATIVE EFFICIENCY",
            insights_p3_b: "Strategic projects achieve the same financial impact with 4-8x less administrative overhead than smaller ones. This validates the focus on large-scale investments to optimize capital use.",
            method_body: `
                <p>This model uses the <b>K-Means</b> algorithm to group CABEI operations based on two critical variables:</p>
                <ul>
                    <li><b>Approved Amount:</b> Log-scaled to handle high data volatility and variance.</li>
                    <li><b>Number of Approvals:</b> Operational frequency by country and year.</li>
                </ul>
                <p><b>Segment Adjustment:</b> Calculated as the inverse Euclidean distance to the centroid, normalized 0 to 100%.</p>
                <p><b>Ellipses:</b> Represent the 95% confidence area for each segment distribution.</p>
            `,
            health_labels: ["Poor", "Moderate", "Good", "Excellent"],
            footer_legal: "¬© 2026 | UNIR‚ÄìBCIE | Academic Collaboration | Team 03-D | All rights reserved.",
            footer_disclaimer: "Results are for academic purposes and do not constitute a binding financial commitment by CABEI.",
            // Content Maps
            sectors: { "Sector Privado": "Private Sector", "Sector P√∫blico": "Public Sector" },
            countries: { 
                "Belice": "Belize", "M√©xico": "Mexico", "Panam√°": "Panama", "Rep√∫blica Dominicana": "Dominican Republic", "Espa√±a": "Spain",
                "Honduras": "Honduras", "Costa Rica": "Costa Rica", "Guatemala": "Guatemala", "El Salvador": "El Salvador", "Nicaragua": "Nicaragua",
                "Colombia": "Colombia", "Argentina": "Argentina", "Cuba": "Cuba", "Regional": "Regional"
            },
            clusterNames: ["Minor Projects", "Regular Projects", "Strategic Projects"],
            // Metrics
            metrics_header_sub: "Bootstrap (N=20)",
            lbl_sil: "Silhouette Score (‚Üë better)",
            lbl_dbi: "Davies-Bouldin (‚Üì better)",
            lbl_ch: "Calinski-Harabasz (‚Üë better)",
            lbl_ari: "Stability (ARI, Bootstrap N=20)",
            lbl_bal: "Balance (Size CV) (‚Üì better)",
            lbl_iner: "Within-cluster Dispersion (WCSS/Inertia) (‚Üì better)",
            diag_title: "Segmentation Diagnosis",
            lbl_mean_std: "Mean ¬± Std",
            lbl_range: "Range",
            lbl_neg: "Silhouette < 0",
            tip_sil: "[-1, 1]",
            tip_dbi: "0+",
            tip_ch: "‚Üë better (compare between models with same data)",
            tip_ari: "0‚Äì1",
            tip_bal: "0+",
            tip_iner: "‚Üì better",
            txt_weak: "Weak", txt_med: "Medium", txt_strong: "Strong", txt_ok: "Ok",
            txt_good: "Good", txt_risk: "Risk",
            badge_check: "Check Method",
            lbl_neg_text: "(possible weak assignments)",
            txt_iters: "",
            model_context: "k=3 | Variables: log(Monto) & #Approvals | Distance: Manhattan",
            lbl_sizes: "Cluster Sizes"
        }
    };

    function updateClusterLabels() {
        const txt = langData[currentLang];
        sortedCentroids.forEach((c, i) => {
            clusterLabels[c.cluster] = txt.clusterNames[i] || `Cluster ${c.cluster}`;
        });
    }

    let currentLang = 'es';
    let currentTheme = 'light';

    function init() {
        updateText();
        updateClusterLabels();
        renderTable();
        // Use requestAnimationFrame to ensure the browser has performed layout
        requestAnimationFrame(() => {
            setTimeout(() => {
                renderCharts();
                renderMatrix();
                updateKPIs();
                // Final resize trigger to ensure Plotly is perfectly aligned
                setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
            }, 600);
        });
    }

    function toggleModal(show) {
        document.getElementById('method-modal').style.display = show ? 'flex' : 'none';
    }

    function toggleInsights(show) {
        document.getElementById('insights-modal').style.display = show ? 'flex' : 'none';
    }

    function toggleMetrics(show) {
        document.getElementById('metrics-modal').style.display = show ? 'flex' : 'none';
        if(show && advancedMetrics) {
            const txt = langData[currentLang];
            const k = dataClusters.length > 0 ? [...new Set(dataClusters.map(d=>d.Cluster))].length : 0;
            const N = dataClusters.length;

            // --- 1. SILHOUETTE ---
            if(k > 1) {
                document.getElementById('adv-sil').innerText = (advancedMetrics.silhouette || 0).toFixed(4);
                document.getElementById('adv-sil-stats').innerText = `${(advancedMetrics.silhouette_mean||0).toFixed(4)} ¬± ${(advancedMetrics.silhouette_std||0).toFixed(4)}`;
                
                // Formatted Neg Silhouette
                const negVal = (advancedMetrics.neg_sil_pct||0).toFixed(1);
                document.getElementById('adv-sil-neg').innerText = `${negVal}%`;

                // Thresholds: Strong >= 0.50 | Medium 0.25-0.49 | Weak < 0.25
                const sil = advancedMetrics.silhouette || 0;
                let silLbl = document.getElementById('adv-sil-lbl');
                
                // Ensure text variables exist
                const tWeak = txt.txt_weak || "Weak"; 
                const tMed = txt.txt_med || "Medium";
                const tStrong = txt.txt_strong || "Strong";
                
                if(sil < 0.25) { silLbl.innerText = tWeak; silLbl.style.color="var(--danger)"; }
                else if(sil < 0.50) { silLbl.innerText = tMed; silLbl.style.color="#f59e0b"; }
                else { silLbl.innerText = tStrong; silLbl.style.color="var(--success)"; }
            } else {
                ['adv-sil', 'adv-sil-stats', 'adv-sil-neg'].forEach(id => document.getElementById(id).innerText = "N/A");
                document.getElementById('adv-sil-lbl').innerText = "N/A";
            }
            
            // --- 2. DAVIES-BOULDIN ---
            if(k > 1) {
                document.getElementById('adv-dbi').innerText = (advancedMetrics.davies_bouldin || 0).toFixed(4);
                document.getElementById('adv-dbi-stats').innerText = `${(advancedMetrics.davies_bouldin_mean||0).toFixed(4)} ¬± ${(advancedMetrics.davies_bouldin_std||0).toFixed(4)}`;
                
                // Thresholds: Strong <= 0.80 | Medium 0.81-1.20 | Weak > 1.20
                const dbi = advancedMetrics.davies_bouldin || 99;
                let dbiLbl = document.getElementById('adv-dbi-lbl');
                const tWeak = txt.txt_weak || "Weak"; 
                const tMed = txt.txt_med || "Medium";
                const tStrong = txt.txt_strong || "Strong";
                
                if(dbi <= 0.80) { dbiLbl.innerText = tStrong; dbiLbl.style.color="var(--success)"; }
                else if(dbi <= 1.20) { dbiLbl.innerText = tMed; dbiLbl.style.color="#f59e0b"; }
                else { dbiLbl.innerText = tWeak; dbiLbl.style.color="var(--danger)"; }
            } else {
                 ['adv-dbi', 'adv-dbi-stats'].forEach(id => document.getElementById(id).innerText = "N/A");
                 document.getElementById('adv-dbi-lbl').innerText = "N/A";
            }

            // --- 3. CALINSKI (1 Decimal) ---
            let ch = (advancedMetrics.calinski_harabasz || 0);
            document.getElementById('adv-ch').innerText = ch.toLocaleString('en-US', {minimumFractionDigits:1, maximumFractionDigits:1});
            
            // --- 4. STABILITY (ARI) ---
            document.getElementById('adv-ari').innerText = (advancedMetrics.stability_ari || 0).toFixed(4);
            document.getElementById('adv-ari-range').innerText = `${(advancedMetrics.ari_min||0).toFixed(4)} - ${(advancedMetrics.ari_max||0).toFixed(4)}`;
            
            // Thresholds: Strong >= 0.80 | Medium 0.65-0.79 | Weak < 0.65 (Using ARI badge check for 1.0 but no semaphore requested explicitly in rules, though user said "ARI 0.87 -> STRONG")
            // Since there is no badge status element in HTML for ARI (only the warning badge), I will leave semantics simple unless I inject one.
            // User did not ask for a semaphore label for ARI, just consistency. Wait, "Quitar UNDEFINED en las 3 tarjetas" (Sil, DBI, Balance). ARI wasn't in list of semaphores to fix UNDEFINED for, but listed rules.
            // I will stick to currently implemented badge logic for "Revisar M√©todo" and add range.
            
            if((advancedMetrics.stability_ari || 0) > 0.999) {
                 document.getElementById('adv-ari-badge').style.display = 'inline-block';
            } else {
                 document.getElementById('adv-ari-badge').style.display = 'none';
            }
            
            // --- 5. BALANCE & SIZES ---
            if(k > 1) {
                document.getElementById('adv-cv').innerText = (advancedMetrics.size_cv || 0).toFixed(4); 
                document.getElementById('adv-min').innerText = (advancedMetrics.min_size_pct || 0).toFixed(1) + "%";
                document.getElementById('adv-max').innerText = (advancedMetrics.max_size_pct || 0).toFixed(1) + "%";
                
                // Thresholds: Strong <= 0.30 | Medium 0.31-0.60 | Weak > 0.60
                let cv = advancedMetrics.size_cv || 0;
                let cvLbl = document.getElementById('adv-cv-lbl');
                
                const tStrong = txt.txt_strong || "Strong"; // CV Low is good => Strong
                const tMed = txt.txt_med || "Medium";
                const tWeak = txt.txt_weak || "Weak";
                
                if(cv <= 0.30) { cvLbl.innerText = tStrong; cvLbl.style.color="var(--success)"; }
                else if(cv <= 0.60) { cvLbl.innerText = tMed; cvLbl.style.color="#f59e0b"; }
                else { cvLbl.innerText = tWeak; cvLbl.style.color="var(--danger)"; }
            } else {
                ['adv-cv', 'adv-min', 'adv-max'].forEach(id => document.getElementById(id).innerText = "N/A");
                document.getElementById('adv-cv-lbl').innerText = "N/A";
            }

            // Calculate & Display Cluster Sizes (Counts)
            const counts = {};
            dataClusters.forEach(d => counts[d.Cluster] = (counts[d.Cluster]||0)+1);
            // Sort by cluster ID to match logical order if needed or just keys
            const sortedKeys = Object.keys(counts).sort((a,b)=>a-b);
            const sizesStr = sortedKeys.map(k => counts[k]).join(" / ");
            document.getElementById('adv-sizes').innerText = sizesStr;
            
            // --- 6. INERTIA / ITERATIONS ---
            document.getElementById('adv-iter').innerText = (advancedMetrics.iterations || 0);
            document.getElementById('adv-inertia').innerText = Math.round(advancedMetrics.inertia || 0).toLocaleString();
            
            // WCSS per point
            let wcss = advancedMetrics.inertia || 0;
            let wcssPerPoint = N > 0 ? (wcss / N) : 0;
            document.getElementById('adv-inertia-per-point').innerText = wcssPerPoint.toFixed(1);
        }
    }

    function renderMatrix() {
        const matrixBody = document.querySelector('#matrix-table tbody');
        const matrixHeader = document.querySelector('#matrix-header');
        matrixBody.innerHTML = '';
        
        // 1. Get Segments (Clusters) sorted
        const clusterIds = sortedCentroids.map(c => c.cluster);
        
        // Update Headers
        const txt = langData[currentLang];
        let headerHTML = `<th style="text-align:left;">${txt.col_country}</th>`;
        clusterIds.forEach(cid => {
             // Use full label as requested
             const label = clusterLabels[cid];
             headerHTML += `<th style="text-align:center">${label}</th>`;
        });
        headerHTML += `<th style="text-align:center">Total</th>`;
        matrixHeader.innerHTML = headerHTML;

        // 2. Aggregate Data and Calculate Column Totals
        const countryMap = {};
        const colTotals = {}; 
        clusterIds.forEach(id => colTotals[id] = 0);
        let grandTotal = 0;
        
        dataClusters.forEach(d => {
            const pais = toTitleCase(d.Pais);
            if(!countryMap[pais]) {
                countryMap[pais] = {
                    total: 0,
                    counts: {} // {clusterId: count}
                };
                clusterIds.forEach(id => countryMap[pais].counts[id] = 0);
            }
            countryMap[pais].counts[d.Cluster]++;
            countryMap[pais].total++;
            
            // Accumulate Grand Totals
            colTotals[d.Cluster]++;
            grandTotal++;
        });

        // 3. Sort Countries by Total
        const sortedCountries = Object.keys(countryMap).sort((a,b) => countryMap[b].total - countryMap[a].total);

        // Define uniform style (matching renderTable)
        const cellStyle = 'vertical-align: middle; font-size: 11px; color: var(--text-dark);';

        // 4. Render Data Rows
        sortedCountries.forEach(pais => {
            const data = countryMap[pais];
            const tr = document.createElement('tr');
            const translatedPais = txt.countries[pais] || pais;
            
            let rowHTML = `<td style="${cellStyle}">${translatedPais}</td>`;
            clusterIds.forEach(cid => {
                const count = data.counts[cid];
                // Clean plain style, matching Detail table
                rowHTML += `<td style="${cellStyle} text-align:center;">${count}</td>`;
            });
            rowHTML += `<td style="${cellStyle} text-align:center; font-weight:700;">${data.total}</td>`;
            
            tr.innerHTML = rowHTML;
            matrixBody.appendChild(tr);
        });

        // 5. Render Total Row
        const totalTr = document.createElement('tr');
        totalTr.style.backgroundColor = 'var(--hover)'; 
        totalTr.style.borderTop = '2px solid var(--primary)';
        
        let totalHTML = `<td style="${cellStyle} font-weight:800;">${txt.txt_total_general}</td>`;
        clusterIds.forEach(cid => {
             totalHTML += `<td style="${cellStyle} text-align:center; font-weight:800;">${colTotals[cid]}</td>`;
        });
        totalHTML += `<td style="${cellStyle} text-align:center; font-weight:800;">${grandTotal}</td>`;
        
        totalTr.innerHTML = totalHTML;
        matrixBody.appendChild(totalTr);
    }

    function updateKPIs() {
        const txt = langData[currentLang];
        document.getElementById('kpi-countries').innerText = dataClusters.length;
        const uniqueClusters = [...new Set(dataClusters.map(d => d.Cluster))];
        const numK = uniqueClusters.length;
        document.getElementById('kpi-k').innerText = numK;
        
        const metric = metricsData.find(d => d.k === numK);
        if(metric) {
            const val = metric.silhouette;
            document.getElementById('kpi-score').innerText = val.toFixed(2);
            
            // Health Label
            let healthIdx = 0;
            if(val > 0.7) healthIdx = 3;      // Excellent
            else if(val > 0.5) healthIdx = 2; // Good
            else if(val > 0.25) healthIdx = 1; // Moderate/Aceptable
            
            const healthLbl = document.getElementById('kpi-health-lbl');
            healthLbl.innerText = txt.health_labels[healthIdx];
            healthLbl.removeAttribute('title');
            healthLbl.setAttribute('data-tooltip', txt.tip_health); 
            healthLbl.style.color = healthIdx >= 2 ? 'var(--success)' : (healthIdx === 1 ? '#f59e0b' : 'var(--danger)');
        }

        // Total Monto
        const total = dataClusters.reduce((sum, d) => sum + d.Monto_Aprobado, 0);
        let fmt = total.toLocaleString();
        if(total > 1e9) fmt = `$${(total/1e9).toFixed(1)}B`;
        else if(total > 1e6) fmt = `$${(total/1e6).toFixed(1)}M`;
        document.getElementById('kpi-total-monto').innerText = fmt;
    }

    function getEllipsePoints(x, y, p=0.95) {
        if (x.length < 3) return [];
        const n = x.length;
        const mx = x.reduce((a, b) => a + b, 0) / n;
        const my = y.reduce((a, b) => a + b, 0) / n;
        
        let sxx = 0, syy = 0, sxy = 0;
        for (let i = 0; i < n; i++) {
            const dx = x[i] - mx;
            const dy = y[i] - my;
            sxx += dx * dx; syy += dy * dy; sxy += dx * dy;
        }
        sxx /= (n - 1); syy /= (n - 1); sxy /= (n - 1);
        
        const trace = sxx + syy;
        const det = sxx * syy - sxy * sxy;
        const root = Math.sqrt(trace * trace / 4 - det);
        const l1 = trace / 2 + root;
        const l2 = trace / 2 - root;
        
        const angle = sxy === 0 ? (sxx > syy ? 0 : Math.PI / 2) : Math.atan2(l1 - sxx, sxy);
        
        const chisq = -2 * Math.log(1 - p);
        const a = Math.sqrt(chisq * l1);
        const b = Math.sqrt(chisq * l2);
        
        const points = [];
        for (let i = 0; i <= 36; i++) {
            const theta = (i / 36) * 2 * Math.PI;
            const px = a * Math.cos(theta);
            const py = b * Math.sin(theta);
            points.push([
                mx + px * Math.cos(angle) - py * Math.sin(angle),
                my + px * Math.sin(angle) + py * Math.cos(angle)
            ]);
        }
        return points;
    }

    function convexHull(points) {
        points.sort((a, b) => a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);
        const n = points.length;
        if (n <= 2) return points;
        const cross = (a, b, o) => (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
        const lower = [];
        for (let i = 0; i < n; i++) {
            while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) lower.pop();
            lower.push(points[i]);
        }
        const upper = [];
        for (let i = n - 1; i >= 0; i--) {
            while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) upper.pop();
            upper.push(points[i]);
        }
        upper.pop(); lower.pop();
        return lower.concat(upper);
    }

    // Helper for title case
    function toTitleCase(str) {
        if(!str) return '';
        return str.toLowerCase().split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
    }

    // --- RENDER TABLE ---
    function renderTable() {
        const tbody = document.querySelector('#data-table tbody');
        tbody.innerHTML = '';
        const colors = ['#105682', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#ec4899'];
        const txt = langData[currentLang];
        
        // 1. Sort Data: Year Desc, then Country Asc
        const sortedData = [...dataClusters].sort((a,b) => {
            const ya = a.Anio || a.Anio_Origen || 0;
            const yb = b.Anio || b.Anio_Origen || 0;
            if(yb !== ya) return yb - ya;
            return a.Pais.localeCompare(b.Pais);
        });

        const maxDist = Math.max(...sortedData.map(d => d.Distancia_Centroide || 0));

        // 2. Render
        sortedData.slice(0, 500).forEach(row => {
            const tr = document.createElement('tr');
            const color = colors[row.Cluster % colors.length];
            const anio = row.Anio || row.Anio_Origen || '-';
            const label = clusterLabels[row.Cluster];
            
            // Translate Content
            const rawSector = row.Sector_Economico || '-';
            const sector = txt.sectors[rawSector] || rawSector;
            const rawPais = toTitleCase(row.Pais);
            const pais = txt.countries[rawPais] || rawPais;
            
            const rawDist = row.Distancia_Centroide || 0;
            const adjScore = Math.round(Math.max(0, (1 - rawDist / (maxDist || 1)) * 100));
            
            let badgeClass = 'conf-low';
            if(adjScore > 80) badgeClass = 'conf-high';
            else if(adjScore > 50) badgeClass = 'conf-med';

            const tdStyle = 'vertical-align: middle;'; 

            tr.innerHTML = `
                <td style="${tdStyle}">${anio}</td>
                <td style="${tdStyle}">${pais}</td>
                <td style="${tdStyle}">${fmtMoney(row.Monto_Aprobado)}</td>
                <td style="${tdStyle} text-align:center;">${row.CANTIDAD_APROBACIONES || 1}</td>
                <td style="${tdStyle}">${sector}</td>
                <td style="${tdStyle} text-align:center;">
                    <span class="conf-badge ${badgeClass}">${adjScore}%</span>
                </td>
                <td style="${tdStyle}">
                    <span class="cluster-tag" style="background:${clusterColorMap[row.Cluster] || '#999'}">${label}</span>
                </td>
            `;
            tbody.appendChild(tr);
        });
    }

    // --- RENDER CHARTS ---
    function renderCharts() {
        // DEFINE SEMANTIC COLORS (Matched to Rank: Low, Mid, High)
        // Rank 0 (Menores): Yellow #f59e0b
        // Rank 1 (Regulares): Green #10b981
        // Rank 2 (Estrat√©gicos): Blue #105682 (Requested)
        const rankColors = ['#f59e0b', '#10b981', '#105682'];
        
        // Map Cluster ID -> Color based on Rank in sortedCentroids
        const clusterColorMap = {};
        const clusterRankMap = {}; // To store rank for legend ordering if needed
        
        sortedCentroids.forEach((c, rank) => {
            // Safety: if we have more than 3 clusters, cycle colors or default
            const color = rankColors[rank] || '#64748b'; 
            clusterColorMap[c.cluster] = color;
            clusterRankMap[c.cluster] = rank;
        });

        // Create an ordered color array where index matches Cluster ID (for Plotly)
        // Plotly usually assigns colors by trace index. We strictly control this or pass specific color array.
        // For 'scatter-chart', we color by point. For 'radar', we color by trace.
        // Easiest is to lookup color by ID during data construction.

        const isDark = currentTheme === 'dark';
        const txtColor = isDark ? '#f1f5f9' : '#1e293b';
        const gridColor = isDark ? '#334155' : '#e2e8f0';
        const txt = langData[currentLang];
        
        // RESTORE MISSING VARIABLES
        const uniqueClusters = [...new Set(dataClusters.map(d => d.Cluster))].sort();
        const currentK = uniqueClusters.length;
        
        // --- 0. SEGMENT INSIGHT CARDS (ORDERED: STRATEGIC -> REGULAR -> MINOR) ---
        const totalMontoGlobal = dataClusters.reduce((s,d) => s + d.Monto_Aprobado, 0);
        const totalOpsGlobal = dataClusters.length;
        const cardsContainer = document.getElementById('segment-cards');
        cardsContainer.innerHTML = '';

        // Reverse sortedCentroids to get High -> Low (Strategic First)
        [...sortedCentroids].reverse().forEach(c => {
            const cid = c.cluster;
            const color = clusterColorMap[cid];
            
            const clusterData = dataClusters.filter(d => d.Cluster === cid);
            const mTotal = clusterData.reduce((s,d) => s + d.Monto_Aprobado, 0);
            const oTotal = clusterData.length;
            const mPct = ((mTotal / totalMontoGlobal) * 100).toFixed(0);
            const oPct = ((oTotal / totalOpsGlobal) * 100).toFixed(0);
            
            const card = document.createElement('div');
            card.className = 'insight-card';
            card.style.borderLeftColor = color;
            card.innerHTML = `
                <div class="insight-card-title">${clusterLabels[cid]}</div>
                <div class="insight-card-main">
                    <div class="insight-card-val" style="color:${color}">${fmtMoney(mTotal)}</div>
                    <div class="insight-card-pct">${mPct}% ${txt.lbl_vol}</div>
                </div>
                <div class="insight-card-footer">
                    <span>${oTotal} ${txt.lbl_ops} (${oPct}%)</span>
                    <span>${fmtMoney(mTotal/oTotal)} / avg</span>
                </div>
            `;
            cardsContainer.appendChild(card);
        });



        // 1. ELBOW & SILHOUETTE
        const traceElbow = {
            x: metricsData.map(d => d.k), y: metricsData.map(d => d.wcss),
            name: currentLang === 'es' ? 'Inercia' : 'Inertia',
            mode: 'lines', line: {color: '#ef4444', width: 3, shape: 'spline', smoothing: 1.3}, 
            type: 'scatter'
        };
        const traceSil = {
            x: metricsData.map(d => d.k), y: metricsData.map(d => d.silhouette),
            name: currentLang === 'es' ? 'Silueta' : 'Silhouette',
            yaxis: 'y2', mode: 'lines', line: {color: '#10b981', width: 3, shape: 'spline', smoothing: 1.3}, 
            type: 'scatter'
        };
        const bestMetric = metricsData.find(d => d.k === currentK);
        const bestK = bestMetric ? bestMetric.k : currentK;

        Plotly.newPlot('elbow-chart', [traceElbow, traceSil], {
            margin: {t:30, l:50, r:40, b:40}, paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
            font: { family: 'Inter', color: txtColor },
            xaxis: {title: 'K Clusters', gridcolor: gridColor},
            yaxis: {title: currentLang==='es'?'Inercia':'Inertia', gridcolor: gridColor},
            yaxis2: {overlaying: 'y', side: 'right', showgrid:false, range:[0,1]},
            legend: {orientation: 'h', y: 1.2},
            annotations: bestMetric ? [{
                x: bestK, y: bestMetric.silhouette, yref: 'y2',
                text: `K=${currentK}`, showarrow: true, arrowhead: 2, ax: 0, ay: -30, font: {color: '#10b981', weight: 'bold'}
            }] : []
        }, {displayModeBar: false});

        // 2. SCATTER + CONFIDENCE ELLIPSES
        const centroidLegendTraces = [];
        const clusterPointTraces = [];
        const ellipseTraces = [];
        const centroidDrawTraces = [];
        
        const hexToRgba = (hex, alpha) => {
            let c;
            if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
                c= hex.substring(1).split('');
                if(c.length== 3) c= [c[0], c[0], c[1], c[1], c[2], c[2]];
                c= '0x'+c.join('');
                return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+alpha+')';
            }
            return hex;
        };
        
        uniqueClusters.forEach(clusterId => {
            const clusterData = dataClusters.filter(d => d.Cluster === clusterId);
            const xLog = clusterData.map(d => Math.log10(d.Monto_Aprobado));
            const yOps = clusterData.map(d => d.CANTIDAD_APROBACIONES);
            
            const ellipsePoints = getEllipsePoints(xLog, yOps, 0.95);
            const colorHex = clusterColorMap[clusterId] || '#999';

            // 1. Ellipse
            if (ellipsePoints.length > 0) {
                ellipseTraces.push({
                    x: ellipsePoints.map(p => Math.pow(10, p[0])), 
                    y: ellipsePoints.map(p => p[1]),
                    fill: 'toself', type: 'scatter', mode: 'lines',
                    line: {width: 1.5, color: colorHex, dash: 'dot'},
                    fillcolor: colorHex, opacity: 0.1,
                    hoverinfo: 'skip', showlegend: false
                });
            }
            
            // 2. Points
            clusterPointTraces.push({
                x: clusterData.map(d => d.Monto_Aprobado),
                y: yOps,
                mode: 'markers', type: 'scatter',
                name: clusterLabels[clusterId],
                text: clusterData.map(d => `${txt.countries[toTitleCase(d.Pais)] || toTitleCase(d.Pais)}<br>${fmtMoney(d.Monto_Aprobado)}`),
                marker: { 
                    size: 8, 
                    color: hexToRgba(colorHex, 0.3), 
                    line: {color: colorHex, width: 1.5} 
                },
                legendgroup: `group_${clusterId}`,
                showlegend: false
            });

            // 3. Centroids
            const cent = centroidsData.find(c => c.cluster === clusterId);
            if(cent) {
                const pref = currentLang === 'es' ? 'Centro ' : 'Center ';
                const lbl = pref + clusterLabels[clusterId];
                centroidDrawTraces.push({
                    x: [cent.monto], y: [cent.aprobaciones],
                    mode: 'markers', type: 'scatter',
                    name: lbl,
                    marker: { size: 16, symbol: 'star', color: colorHex, line: {width:1.5, color:isDark?'#000':'#fff'} },
                    hoverinfo: 'text', text: [`${lbl}<br>${fmtMoney(cent.monto)}`],
                    showlegend: false
                });
            }
        });

        // LEGEND (Manual HTML)
        const legendDiv = document.getElementById('scatter-legend');
        let legHTML = '<div class="legend-row">';
        sortedCentroids.forEach(c => {
            const color = clusterColorMap[c.cluster] || '#999';
            legHTML += `<div class="legend-item"><span style="color:${color}; font-size:16px;">‚òÖ</span> ${clusterLabels[c.cluster]}</div>`;
        });
        legHTML += '</div>';
        legendDiv.innerHTML = legHTML;

        Plotly.newPlot('scatter-chart', [...ellipseTraces, ...clusterPointTraces, ...centroidDrawTraces], {
            margin: {t:10, l:50, r:20, b:40},
            paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
            font: { family: 'Inter', color: txtColor },
            xaxis: {title: txt.xaxis_monto, type: 'log', gridcolor: gridColor, zeroline: false},
            yaxis: {title: currentLang==='es'?'Aprobaciones':'Approvals', gridcolor: gridColor, zeroline: false},
            hovermode: 'closest', showlegend: false
        }, {displayModeBar: false});

        // 3. DUMBBELL CHART (Profile)
        // Ensure cluster labels are fresh
        updateClusterLabels();
        const centroidsData_copy = [...centroidsData].sort((a,b) => a.monto - b.monto);
        
        const mVals = centroidsData_copy.map(c => parseFloat(c.monto));
        const aVals = centroidsData_copy.map(c => parseFloat(c.aprobaciones));
        const minMonto = Math.min(...mVals); const maxMonto = Math.max(...mVals);
        const minAprob = Math.min(...aVals); const maxAprob = Math.max(...aVals);
        const rangeMonto = (maxMonto - minMonto) || 1;
        const rangeAprob = (maxAprob - minAprob) || 1;

        const yCategories = centroidsData_copy.map(c => clusterLabels[c.cluster]);
        const mScores = mVals.map(v => Math.round(((v - minMonto) / rangeMonto) * 100));
        const aScores = aVals.map(v => Math.round(((v - minAprob) / rangeAprob) * 100));

        const connectorTraces = centroidsData_copy.map((c, i) => ({
            x: [mScores[i], aScores[i]], y: [yCategories[i], yCategories[i]],
            mode: 'lines', line: { color: gridColor, width: 2 }, opacity: 0.4, showlegend: false
        }));

        const traceMonto = {
            x: mScores, y: yCategories, name: txt.lbl_monto, mode: 'markers+text',
            marker: { color: '#003366', size: 12 }, text: mScores, textposition: 'middle right', 
            textfont: { size: 11, color: txtColor }, texttemplate: '%{x}', cliponaxis: false,
            hovertemplate: centroidsData_copy.map((c, i) => `<b>${clusterLabels[c.cluster]}</b><br>${txt.lbl_monto}: ${fmtMoney(mVals[i])}<extra></extra>`),
            showlegend: false
        };

        const traceAprob = {
            x: aScores, y: yCategories, name: txt.lbl_proyectos, mode: 'markers+text',
            marker: { color: '#10b981', size: 12 }, text: aScores, textposition: 'middle right', 
            textfont: { size: 11, color: txtColor }, texttemplate: '%{x}', cliponaxis: false,
            hovertemplate: centroidsData_copy.map((c, i) => `<b>${clusterLabels[c.cluster]}</b><br>${txt.lbl_proyectos}: ${Math.round(aVals[i])}<extra></extra>`),
            showlegend: false
        };

        const annotations = centroidsData_copy.map((c, i) => {
            const label = clusterLabels[c.cluster];
            const desc = label.includes('Estrat√©') || label.includes('Strate') ? txt.desc_estr : (label.includes('Regu') ? txt.desc_regu : txt.desc_meno);
            return {
                xref: 'paper', x: 1.05, yref: 'y', y: yCategories[i],
                text: `<i style="color:${txtColor}; opacity:0.6; font-size:11px;">${desc}</i>`,
                showarrow: false, xanchor: 'left', yanchor: 'middle'
            };
        });

        // Legend markers
        const legTraces = [
            { x:[null], y:[yCategories[0]], mode:'markers', marker:{color:'#003366', size:10}, name:txt.lbl_monto },
            { x:[null], y:[yCategories[0]], mode:'markers', marker:{color:'#10b981', size:10}, name:txt.lbl_proyectos }
        ];

        const config = { responsive: true, displayModeBar: false };
        const chartDiv = document.getElementById('radar-chart');

        Plotly.react(chartDiv, [...connectorTraces, traceMonto, traceAprob, ...legTraces], {
            margin: {t:40, b:40, l:130, r:180}, paper_bgcolor: 'transparent', plot_bgcolor: 'transparent',
            font: { family: 'Inter', color: txtColor }, showlegend: true,
            legend: {orientation: 'h', y: 1.2, x: 0.5, xanchor:'center'},
            xaxis: { range: [-15, 125], tickvals: [0, 25, 50, 75, 100], showgrid: true, gridcolor: gridColor, zeroline: false },
            yaxis: { 
                type: 'category',
                categoryorder: 'array',
                categoryarray: yCategories,
                showgrid: false, 
                automargin: true
            },
            shapes: [{ type: 'line', xref: 'x', x0: 50, x1: 50, yref: 'paper', y0: 0, y1: 1, line: { color: gridColor, dash: 'dot', width:1 }, opacity: 0.3 }],
            annotations: annotations
        }, config);
    }

    // Helper
    function fmtMoney(val) {
        if(val >= 1e9) return '$' + (val/1e9).toFixed(1) + 'B';
        if(val >= 1e6) return '$' + (val/1e6).toFixed(1) + 'M';
        return '$' + val.toLocaleString(undefined, {maximumFractionDigits:0});
    }

    // --- TOGGLES ---
    function toggleTheme() {
        currentTheme = currentTheme === 'light' ? 'dark' : 'light';
        document.documentElement.setAttribute('data-theme', currentTheme);
        document.getElementById('btn-theme').classList.toggle('active');
        renderCharts();
    }

    function toggleLang() {
        currentLang = currentLang === 'es' ? 'en' : 'es';
        document.getElementById('btn-lang').classList.toggle('active');
        
        // Update simple texts first
        updateText();
        updateKPIs();
        updateClusterLabels();
        
        // Then re-render complex components
        try { renderCharts(); } catch(e){ console.error(e); }
        try { renderTable(); } catch(e){ console.error(e); }
        try { renderMatrix(); } catch(e){ console.error(e); }
    }

    function updateText() {
        const t = langData[currentLang];
        document.querySelectorAll('[data-key]').forEach(el => {
            const key = el.getAttribute('data-key');
            if(t[key]) {
                if(key === 'method_body') el.innerHTML = t[key];
                else el.innerText = t[key];
            }
        });
        document.getElementById('lbl-theme-light').innerText = t.txt_theme_light;
        document.getElementById('lbl-theme-dark').innerText = t.txt_theme_dark;
        document.getElementById('lbl-lang-es').innerText = t.txt_lang_es;
        document.getElementById('lbl-lang-en').innerText = t.txt_lang_en;
        document.getElementById('btn-snap-txt').innerText = t.txt_snap;
        document.getElementById('btn-pdf-txt').innerText = t.txt_pdf;
        
        // Update Tooltips
        document.querySelectorAll('[data-key-tooltip]').forEach(el => {
            const key = el.getAttribute('data-key-tooltip');
            if(t[key]) el.setAttribute('data-tooltip', t[key]);
        });
        
        // Refresh dynamic metric labels if modal is open
        if(document.getElementById('metrics-modal').style.display !== 'none') {
            toggleMetrics(true);
        }
    }

    // --- ACTIONS ---
    async function takeScreenshot() {
        const btn = document.getElementById('btn-snap-txt');
        const orig = btn.innerText;
        btn.innerText = '...';
        try {
            const canvas = await html2canvas(document.body, {useCORS: true});
            const link = document.createElement('a');
            link.download = `Snapshot_KMeans_${new Date().toISOString().slice(0,19)}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        } catch(e) { console.error(e); alert('Error'); }
        btn.innerText = orig;
    }

    async function generatePDF() {
        const { jsPDF } = window.jspdf;
        const btn = document.getElementById('btn-pdf-txt');
        const orig = btn.innerText;
        btn.innerText = '...';
        
        try {
            const canvas = await html2canvas(document.body, {scale: 1, useCORS: true});
            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF('p', 'mm', 'a4');
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = pdf.internal.pageSize.getHeight();
            const imgWidth = canvas.width;
            const imgHeight = canvas.height;
            const ratio = Math.min(pdfWidth / imgWidth, pdfHeight / imgHeight);
            
            pdf.addImage(imgData, 'PNG', 0, 0, imgWidth * ratio, imgHeight * ratio);
            pdf.save('Report_KMeans.pdf');
        } catch(e) { console.error(e); alert('Error PDF'); }
        btn.innerText = orig;
    }

    window.addEventListener('load', init);
</script>
</body>
</html>
